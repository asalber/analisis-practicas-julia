{
  "hash": "092e77918d8cec2221dcffce62ee6f79",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Funciones vectoriales\nlang: es\n---\n\n## Ejercicios Resueltos\n\nPara la realización de esta práctica se requieren los siguientes paquetes:\n\n```julia\nusing SymPy  # Para el cálculo simbólico.\nusing Plots  # Para el dibujo de gráficas.\nusing Makie, GLMakie # Para el dibújo de gráficas en 3d.\nusing LaTeXStrings  # Para usar código LaTeX en los gráficos.\nusing LinearAlgebra # Para el módulo, producto escalar y vectorial de vectores.\nusing Roots # Para calcular soluciones de ecuaciones numéricamente.\n```\n\n:::{#exr-vectores}\nRepresentar gráficamente los vectores $\\mathbf{u}=(3,1)$, $\\mathbf{v}=(1,2)$ y $\\mathbf{u}-\\mathbf{v}$ en el plano real $\\mathbb{R}^2$.\n\n:::{.callout-note collapse=\"true\"}\n## Ayuda\nUsar la función [`plot`](https://aprendeconalf.es/manual-julia/graficos.html#gr%C3%A1fica-de-una-funci%C3%B3n-de-una-variable) del paquete `Plots`, añadiendo el parámetro `arrow = true` para dibujar flechas que representan vectores.\nTambién se puede usar la función [`arrows!`](https://docs.makie.org/stable/reference/plots/arrows) del paquete `Makie` para dibujar flechas.\n:::\n\n:::{.callout-tip collapse=\"true\"}\n## Solución\n\n:::{.panel-tabset}\n\n## Plots\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Plots\nusing LaTeXStrings\nPlots.plot([0, 3], [0, 1], arrow = true, linewidth = 2, legend = false)\nannotate!(1.5, 0.4, L\"$\\mathbf{u}$\")\nPlots.plot!([0, 1], [0, 2], arrow = true, linewidth = 2)\nannotate!(0.4, 1, L\"$\\mathbf{v}$\")\nPlots.plot!([3, 1], [1, 2], arrow = true, linewidth = 2)\nannotate!(2.1, 1.6, L\"$\\mathbf{u}-\\mathbf{v}$\")\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n![](08-funciones-vectoriales_files/figure-pdf/cell-2-output-1.svg){fig-pos='H'}\n:::\n:::\n\n\n## Makie\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nusing GLMakie\nusing LaTeXStrings\no = Point2(0, 0)\nu = Vec2(3, 1)\nv = Vec2(1, 2)\nfig = Figure()\nax = Axis(fig[1,1])\narrows!(ax, [o], [u], color = :blue)\ntext!(ax, 1.5, 0.4, text = L\"$\\mathbf{u}$\")\narrows!(ax, [o], [v], color = :red)\ntext!(ax, 0.4, 1, text = L\"$\\mathbf{v}$\")\narrows!(ax, [o+v], [u-v], color = :green)\ntext!(ax, 2.1, 1.6, text = L\"$\\mathbf{u}-\\mathbf{v}$\")\nfig\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n![](08-funciones-vectoriales_files/figure-pdf/cell-3-output-1.png){fig-pos='H'}\n:::\n:::\n\n\n:::\n:::\n:::\n\n:::{#exr-producto-escalar-vectorial}\nSean $\\mathbf{u}=(1,2,-1)$ y $\\mathbf{v}=(3,0,2)$ dos vectores del espacio real $\\mathbb{R}^3$.\n\na.  Calcular el módulo (norma) de ambos vectores y construir vectores unitarios con su misma dirección.\n\n    :::{.callout-note collapse=\"true\"}\n    ## Ayuda\n    Usar la función [`norm`](https://aprendeconalf.es/manual-julia/tipos-datos-compuestos.html#%C3%A1lgebra-lineal-con-vectores) del paquete `LinearAlgebra` para calular el módulo de un vector.\n    :::\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución\n\n\n    ::: {.cell execution_count=3}\n    ``` {.julia .cell-code}\n    using LinearAlgebra\n    u = [-1, 2, -1]\n    v = [-2, 0, 1]\n    println(\"Módulo de u: $(norm(u))\")\n    println(\"Módulo de v: $(norm(v))\")\n    println(\"Vector unitario con la dirección de u $(u/norm(u))\")\n    println(\"Vector unitario con la dirección de v $(v/norm(v))\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    Módulo de u: 2.449489742783178\n    Módulo de v: 2.23606797749979\n    Vector unitario con la dirección de u [-0.4082482904638631, 0.8164965809277261, -0.4082482904638631]\n    Vector unitario con la dirección de v [-0.8944271909999159, 0.0, 0.4472135954999579]\n    ```\n    :::\n    :::\n    \n    \n    :::\n\na.  Calcular su producto escalar.\n\n    :::{.callout-note collapse=\"true\"}\n    ## Ayuda\n    Usar la función [`dot`](https://aprendeconalf.es/manual-julia/tipos-datos-compuestos.html#%C3%A1lgebra-lineal-con-vectores) del paquete `LinearAlgebra` para calcular el producto escalar de dos vectores.\n    :::\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución\n\n\n    ::: {.cell execution_count=4}\n    ``` {.julia .cell-code}\n    println(\"Producto escalar de u y v: $(dot(u, v))\")\n    # También se puede usar el clásico punto ⋅\n    println(\"Producto escalar de u y v: $(u ⋅ v)\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    Producto escalar de u y v: 1\n    Producto escalar de u y v: 1\n    ```\n    :::\n    :::\n    \n    \n    :::\n\na.  Calcular su producto vectorial.\n\n    :::{.callout-note collapse=\"true\"}\n    ## Ayuda\n    Usar la función [`cross`](https://aprendeconalf.es/manual-julia/tipos-datos-compuestos.html#%C3%A1lgebra-lineal-con-vectores) del paquete `LinearAlgebra` para calcular el producto vectorial de dos vectores.\n    :::\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución\n\n\n    ::: {.cell execution_count=5}\n    ``` {.julia .cell-code}\n    println(\"Producto vectorial de u y v: $(cross(u, v))\")\n    # También se puede usar la clásica cruz × \n    println(\"Producto vectorial de u y v: $(u × v)\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    Producto vectorial de u y v: [2, 3, 4]\n    Producto vectorial de u y v: [2, 3, 4]\n    ```\n    :::\n    :::\n    \n    \n    :::\n\na.  Dibujar $\\mathbf{u}$, $\\mathbf{v}$ y $\\mathbf{u}\\times\\mathbf{v}$ en el espacio real.\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución\n    :::{.panel-tabset}\n    ## Plots\n\n\n    ::: {.cell execution_count=6}\n    ``` {.julia .cell-code}\n    using Plots\n    uv = u × v\n    Plots.plot([0, u[1]], [0, u[2]], [0, u[3]], arrow = true, linewidth = 2, xlabel = \"X\", ylabel = \"Y\", zlabel = \"Z\", legend = false)\n    Plots.plot!([0, v[1]], [0, v[2]], [0, v[3]], arrow = true, linewidth = 2)\n    Plots.plot!([0, uv[1]], [0, uv[2]], [0, uv[3]], arrow = true, linewidth = 2)\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=7}\n    ![](08-funciones-vectoriales_files/figure-pdf/cell-7-output-1.svg){fig-pos='H'}\n    :::\n    :::\n    \n    \n    ## Makie\n\n\n    ::: {.cell execution_count=7}\n    ``` {.julia .cell-code}\n    using GLMakie\n    fig = Figure()\n    ax = Axis3(fig[1,1], azimuth = -pi/4, aspect = (1,1,1))\n    O = [0, 0 ,0]\n    arrows!(ax, [Point3(O)], [Vec3(u), Vec3(v), Vec3(u × v)], \n        linecolor = [:blue,:red, :green], arrowcolor = [:blue,:red, :green],\n        linewidth = 0.02, arrowsize = Vec3(0.1, 0.1, 0.1))\n    fig\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=8}\n    ![](08-funciones-vectoriales_files/figure-pdf/cell-8-output-1.png){fig-pos='H'}\n    :::\n    :::\n    \n    \n    :::\n    :::\n:::\n\n:::{#exr-grafica-trayectorias}\nDibujar las trayectorias de las siguientes funciones vectoriales.\n\na.  $f(t)=(\\operatorname{sen}(t), \\cos(t))$.\n\n    :::{.callout-note collapse=\"true\"}\n    ## Ayuda\n    Usar la función [`plot`](https://aprendeconalf.es/manual-julia/graficos.html#gr%C3%A1fica-de-una-funci%C3%B3n-de-una-variable) del paquete `Plots`  o la función [`lines`](https://aprendeconalf.es/manual-julia/graficos.html#diagrama-de-l%C3%ADneas) del paquete `Makie` para dibujar la trayectoria, pasándole cada una de las funciones componentes separadas por comas.\n    :::\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución \n\n    :::{.panel-tabset}\n    ## Plots\n\n\n    ::: {.cell execution_count=8}\n    ``` {.julia .cell-code}\n    using Plots\n    f(t) = [sin(t), cos(t)] \n    ts = range(0, 2pi, length = 200)\n    xs = [f(t)[1] for t in ts]\n    ys = [f(t)[2] for t in ts]\n    Plots.plot(xs, ys, aspect_ratio = :equal)\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=9}\n    ![](08-funciones-vectoriales_files/figure-pdf/cell-9-output-1.svg){fig-pos='H'}\n    :::\n    :::\n    \n    \n    ## Makie\n\n\n    ::: {.cell execution_count=9}\n    ``` {.julia .cell-code}\n    using GLMakie\n    f(t) = [sin(t), cos(t)] \n    ts = range(0, 2pi, length = 200)\n    points = Point2.(f.(ts))\n    fig = Figure()\n    ax = Axis(fig[1,1], aspect = 1)\n    lines!(ax, points, linewidth = 2, color = :blue)\n    fig\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=10}\n    ![](08-funciones-vectoriales_files/figure-pdf/cell-10-output-1.png){fig-pos='H'}\n    :::\n    :::\n    \n    \n    :::\n    :::\n\na.  $\\mathbf{g}(t) = (\\cos(t), \\operatorname{sen}(t), t/4)$.\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución \n    :::{.panel-tabset}\n    ## Plots\n\n\n    ::: {.cell execution_count=10}\n    ``` {.julia .cell-code}\n    g(t) = [cos(t), sin(t), t/4] \n    ts = range(0, 2pi, length = 200)\n    xs = [g(t)[1] for t in ts]\n    ys = [g(t)[2] for t in ts]\n    zs = [g(t)[3] for t in ts]\n    Plots.plot(xs, ys, zs, aspect_ratio = :equal, xlabel = \"X\", ylabel = \"Y\", zlabel = \"Z\", label = \"\")\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=11}\n    ![](08-funciones-vectoriales_files/figure-pdf/cell-11-output-1.svg){fig-pos='H'}\n    :::\n    :::\n    \n    \n    ## Makie\n\n\n    ::: {.cell execution_count=11}\n    ``` {.julia .cell-code}\n    using GLMakie\n    g(t) = [cos(t), sin(t), t/4] \n    ts = range(0, 2pi, length = 200)\n    points = Point3.(g.(ts))\n    fig = Figure()\n    ax = Axis3(fig[1,1])\n    lines!(ax, points, linewidth = 2, color = :blue)\n    fig\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=12}\n    ![](08-funciones-vectoriales_files/figure-pdf/cell-12-output-1.png){fig-pos='H'}\n    :::\n    :::\n    \n    \n    :::\n    :::\n:::\n\n:::{#exr-nudos-toricos}\nUn [nudo tórico](https://en.wikipedia.org/wiki/Torus_knot) es un nudo que se forma mediante una trayectoria que gira sobre la superficie de un toro en $\\mathbb{R}^3$. La función vectorial que define este tipo de nudos sobre un toro de ecuación $(r-2)^2+z^2 = 1$ es $\\mathbf{f}(t) = ((2+\\cos(qt))\\cos(pt), (2+\\cos(qt))\\operatorname{sen}(pt), -\\operatorname{sen}(qt))$, donde $p$ y $q$ son dos enteros primos entre si y $t\\in [0,2\\pi]$.\n\na.  Dibujar el nudo tórico  con $p=2$ y $q=3$.\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución\n\n    Usando el paquete `Makie`.\n\n\n    ::: {.cell execution_count=12}\n    ``` {.julia .cell-code}\n    using GLMakie\n    # Definimos las ecuaciones paramétricas del toro.\n    U = range(-pi, pi, 100)\n    V = range(-pi, pi, 20)\n    x1 = [2cos(u) + cos(u) * cos(v) for u in U, v in V]\n    y1 = [2sin(u) + sin(u) * cos(v) for u in U, v in V]\n    z1 = [sin(v) for u in U, v in V]\n    # Inicializamos la figura y los ejes.\n    fig = Figure()\n    ax = Axis3(fig[1,1], aspect = (3, 3, 1))\n    # Dibujamos el toro.\n    Makie.surface!(ax, x1, y1, z1; colormap = :viridis, transparency = true, alpha = 0.5)\n    # Definimos la función vectorial de nudo tórico.\n    f(t) = [(2+cos(3t))cos(2t), (2+cos(3t))sin(2t), -sin(3t)] \n    # Generamos los puntos de la trayectoria del nudo tórico.\n    ts = range(0, 2pi, length = 200)\n    points = Point3.(f.(ts))\n    # Dibujamos el nudo tórico.\n    lines!(ax, points, linewidth = 3, color = :red)\n    fig\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=13}\n    ![](08-funciones-vectoriales_files/figure-pdf/cell-13-output-1.png){fig-pos='H'}\n    :::\n    :::\n    \n    \n    :::\n\na.  Definir una función para crear nudos tóricos con parámetros `p` y `q` para los enteros que definen el toro y un parámetro opcional booleano `toro`, para dibujar el toro o no.\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución\n\n\n    ::: {.cell execution_count=13}\n    ``` {.julia .cell-code}\n    using GLMakie\n    \"\"\"\n        nudo_torico(ax, p, q, toro)\n    \n    Función dibuja un nudo tórico de parámetros p, q sobre los ejes ax. Si el parámetro toro es true dibuja también el toro sobre el que se traza el nudo.\n    \"\"\"\n    function nudo_torico(ax::Axis3, p::Int64, q::Int64, toro::Bool = true)\n        if toro \n            alpha = 0.5\n        else\n            alpha = 0\n        end\n        # Definimos las ecuaciones paramétricas del toro.\n        U = range(-pi, pi, 100)\n        V = range(-pi, pi, 20)\n        x1 = [2cos(u) + cos(u) * cos(v) for u in U, v in V]\n        y1 = [2sin(u) + sin(u) * cos(v) for u in U, v in V]\n        z1 = [sin(v) for u in U, v in V]\n        # Dibujamos el toro en los ejes.\n        Makie.surface!(ax, x1, y1, z1; colormap = :viridis, transparency = true, alpha = alpha)\n        # Definimos la función vectorial de nudo tórico.\n        f(t) = [(2+cos(q*t))cos(p*t), (2+cos(q*t))sin(p*t), -sin(q*t)] \n        # Generamos los puntos de la trayectoria del nudo tórico.\n        ts = range(0, 2pi, length = 200)\n        points = Point3.(f.(ts))\n        # Dibujamos el nudo tórico.\n        lines!(ax, points, linewidth = 3, color = :red)\n    end\n    \n    fig = Figure()\n    ax = Axis3(fig[1,1], aspect = (3, 3, 1))\n    nudo_torico(ax, 5, 9, true)\n    fig\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=14}\n    ![](08-funciones-vectoriales_files/figure-pdf/cell-14-output-1.png){fig-pos='H'}\n    :::\n    :::\n    \n    \n    :::\n:::\n\n:::{#exr-tangente-normal}\na.  Calcular las ecuaciones de la rectas tangente y normal a la trayectoria $\\mathbf{f}(t) = (\\operatorname{sen}(2t), \\cos(t))$ en el punto correspondiente a $t=\\pi/2$ y dibujarlas.\n\n    :::{.callout-note collapse=\"true\"}\n    ## Ayuda\n    La ecuación de la recta tangente a la trayectoria de la función vectorial $\\mathbf{f}(t)$ en el instante $t=a$ es $\\mathbf{f}(a)+\\mathbf{f}'(a)t$.\n\n    La ecuación de la recta normal a la trayectoria de la función vectorial $\\mathbf{f}(t)$ en el instante $t=a$ es $\\mathbf{f}(a)+\\mathbf{N}(a)t$, donde $\\mathbf{N}(a)$ es un vector normal a $f'(a)$, como por ejemplo $\\mathbf{N}(a) = (f'(a)_2, -f'(a)_1)$.\n    :::\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución\n\n    :::{.panel-tabset}\n    ## Plots\n\n\n    ::: {.cell execution_count=14}\n    ``` {.julia .cell-code}\n    using SymPy, Plots\n    @syms t::real\n    # Definimos la función vectorial.\n    f(t) = [sin(2t), cos(t)]\n    # Instante \n    a = pi/2\n    # Dibujamos la trayectoria.\n    Plots.plot(f(t)..., 0, 2pi, aspect_ratio = :equal, label = \"f(t)=(sen(t), cos(t))\")\n    # Dibujamos el punto de tangencia.\n    Plots.scatter!([f(a)[1]],[f(a)[2]], label = \"\")\n    # Calculamos la función derivada.\n    df = lambdify(diff.(f(t)))\n    # Calculamos la ecuación de la recta tangente.\n    tl(t) = f(a) + df(a) * t\n    # Dibujamos la recta tangente.\n    Plots.plot!(tl(t)..., -1, 1, label = \"Tangente\")\n    # Calculamos la ecuación de la recta normal.\n    nl(t) = f(a) - [df(a)[2],-df(a)[1]] * t\n    Plots.plot!(nl(t)..., -0.6, 0.6, label = \"Normal\")\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=15}\n    ![](08-funciones-vectoriales_files/figure-pdf/cell-15-output-1.svg){fig-pos='H'}\n    :::\n    :::\n    \n    \n    ## Makie\n\n\n    ::: {.cell execution_count=15}\n    ``` {.julia .cell-code}\n    using SymPy, GLMakie\n    @syms t::real\n    # Definimos la función vectorial.\n    f(t) = [sin(2t), cos(t)]\n    # Instante\n    a = pi/2\n    # Dibujamos la trayectoria.\n    ts = range(0, 2pi, 200)\n    points = Point2.(f.(ts))\n    fig = Figure()\n    ax = Axis(fig[1,1], aspect = DataAspect())\n    lines!(ax, points)\n    # Dibujamos el punto de tangencia.\n    Makie.scatter!(Point2(f(a)), color = :red)\n    # Calculamos la función derivada.\n    df = lambdify(diff.(f(t)))\n    # Calculamos la ecuación de la recta tangente.\n    tl(t) = f(a) + df(a) * t\n    # Dibujamos la recta tangente.\n    pointstl = Point2.(tl.(range(-1, 1, 2)))\n    lines!(ax, pointstl)    \n    # Calculamos la ecuación de la recta normal\n    nl(t) = f(a) - [df(a)[2],-df(a)[1]] * t\n    pointsnl = Point2.(nl.(range(-0.6, 0.6, 2)))\n    lines!(ax, pointsnl)\n    fig\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=16}\n    ![](08-funciones-vectoriales_files/figure-pdf/cell-16-output-1.png){fig-pos='H'}\n    :::\n    :::\n    \n    \n    :::\n    :::\n\na.  Calcular las ecuaciones de las recta tangente y el plano normal a la trayectoria $\\mathbf{g}(t) = (\\cos(t), \\operatorname{sen}(t), \\sqrt{t})$ en punto correspondiente a $t=\\pi/2$ y dibujarlas.\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución\n\n\n    ::: {.cell execution_count=16}\n    ``` {.julia .cell-code}\n    using SymPy, LinearAlgebra, GLMakie\n    @syms x, y, z, t\n    # Definimos la función vectorial.\n    g(t) = [cos(t), sin(t), sqrt(t)]\n    # Instante \n    a = pi/2\n    # Dibujamos la trayectoria.\n    ts = range(0, 2pi, 200)\n    points = Point3.(g.(ts))\n    fig = Figure()\n    ax = Axis3(fig[1,1], title = \"Recta tangente y plano normal a una trayectoria\", aspect = :equal)\n    lines!(ax, points)\n    # Dibujamos el punto de tangencia.\n    Makie.scatter!(Point3(g(a)), color = :red)\n    # Calculamos la derivada en el punto.\n    dg = lambdify(diff.(g(t)))\n    # Calculamos la ecuación de la recta tangente.\n    tl(t) = g(a) + dg(a) * t\n    # Dibujamos la recta tangente.\n    pointstl = Point3.(tl.(range(-pi, pi, 2)))\n    lines!(ax, pointstl)\n    # Calculamos la ecuación del plano normal\n    np = lambdify(solve(dot(([x, y, z] - g(a)), dg(a)), z)[1])\n    xs = range(-1, 1, 2)\n    ys = range(0, 2, 2)\n    zs = [np(x,y) for x in xs, y in ys]\n    Makie.surface!(ax, xs, ys, zs, colormap = [\"red\"], alpha = 0.5, transparency = true)\n    fig\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=17}\n    ![](08-funciones-vectoriales_files/figure-pdf/cell-17-output-1.png){fig-pos='H'}\n    :::\n    :::\n    \n    \n    :::\n:::\n\n:::{#exr-plano-osculador}\nDada una función vectorial $\\mathbf{f}(t)$ en $\\mathbb{R}^3$, el _plano osculador_ de la trayectoria de $\\mathbf{f}(t)$ en $t=a$ es el plano definido por los vectores tangente $\\mathbf{T}(a)$ y normal $\\mathbf{N}(a)$. \n\nCalcular y dibujar el plano osculador de la función vectorial del nudo tórico del apartado a del ejercicio @exr-nudos-toricos en el punto correspondiente a $t=\\pi/2$.\n\n:::{.callout-tip collapse=\"true\"}\n## Solución\n\nUsando el paquete `Makie`.\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\nusing SymPy, LinearAlgebra, GLMakie\n@syms x, y, z, t::real\n# Definimos las ecuaciones paramétricas del toro.\nU = range(-pi, pi, 100)\nV = range(-pi, pi, 20)\nx1 = [2cos(u) + cos(u) * cos(v) for u in U, v in V]\ny1 = [2sin(u) + sin(u) * cos(v) for u in U, v in V]\nz1 = [sin(v) for u in U, v in V]\n# Inicializamos la figura y los ejes.\nfig = Figure()\nax = Axis3(fig[1,1], aspect = (3, 3, 1))\n# Dibujamos el toro.\nMakie.surface!(ax, x1, y1, z1; colormap = :viridis, shading = false, transparency = true, alpha = 0.5)\n# Definimos la función vectorial de nudo tórico.\nf(t) = [(2+cos(3t))cos(2t), (2+cos(3t))sin(2t), -sin(3t)] \n# Generamos los puntos de la trayectoria del nudo tórico.\nts = range(0, 2pi, length = 200)\npoints = Point3.(f.(ts))\n# Dibujamos el nudo tórico.\nlines!(ax, points, linewidth = 3, color = :red)\n# Punto\na = pi/2\n# Dibujamos el punto.\nMakie.scatter!(ax, Point3(f(a)))\n# Vector tangente unitario.\nTan = lambdify(diff.(f(t)) / norm(diff.(f(t))))\n# Vector normal unitario.\nNorm = lambdify(diff.(Tan(t)) / norm(diff.(Tan(t))))\n# Calculamos la ecuación del plano osculador.\npo = lambdify(solve(dot(([x, y, z] - f(a)), cross(Tan(a), Norm(a))), z)[1])\nxs = range(-3, -1, 2)\nys = range(-1, 1, 2)\nzs = [po(x,y) for x in xs, y in ys]\nMakie.surface!(ax, xs, ys, zs, colormap = [\"magenta\"], alpha = 0.8, transparency = true)\nfig\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Warning: `shading = false` is not valid. Use `Makie.automatic`, `NoShading`, `FastShading` or `MultiLightShading`. Defaulting to `NoShading`.\n└ @ Makie ~/.julia/packages/Makie/YkotL/src/lighting.jl:243\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=18}\n![](08-funciones-vectoriales_files/figure-pdf/cell-18-output-2.png){fig-pos='H'}\n:::\n:::\n\n\n:::\n:::\n\n:::{#exr-longitud-trayectoria}\nPara construir un cuaderno de 30 cm de altura se utiliza una espiral de alambre con radio 1 cm y una distancia entre cada dos vueltas consecutivas $\\pi/4$ cm. Dibujar la espiral y calcular la cantidad de alambre necesaria para cada cuaderno.\n\n:::{.callout-note collapse=\"true\"}\n## Ayuda\nLa [longitud de la trayectoria de una función vectorial](https://aprendeconalf.es/analisis-manual/12-funciones-vectoriales.html#longitud-de-la-trayectoria-de-una-funci%C3%B3n-vectorial) $\\mathbf{f}(t)$ en el intervalo $t\\in [a,b]$ se calcula mediante la integral\n\n$$\n\\int_a^b |\\mathbf{f}'(t)|\\, dt\n$$\n:::\n\n:::{.callout-tip collapse=\"true\"}\n## Solución\nDibujamos primero la espiral.\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\nusing SymPy, GLMakie\n@syms t::real\n# Definimos la función vectorial.\nf(t) = [cos(t), sin(t), t/8]\n# Calculamos el número de revoluciones.\nh = N(solve(f(t)[3]-30)[1])\n# Dibujamos la trayectoria.\nts = range(0, h, 2000)\npoints = Point3.(f.(ts))\nfig = Figure()\nax = Axis3(fig[1,1], title = \"Espiral de un cuaderno\", aspect = (1, 1, 30))\nlines!(ax, points)\nfig\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n![](08-funciones-vectoriales_files/figure-pdf/cell-19-output-1.png){fig-pos='H'}\n:::\n:::\n\n\nA continuación calculamos la longitud de la espiral.\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\nusing LinearAlgebra\n# Calculamos longitud de la trayectoria\nN(integrate(norm(diff.(f(t))), (t, 0, h)))\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n241.8677324489565\n```\n:::\n:::\n\n\n:::\n:::\n\n:::{#exr-curvatura}\nDibujar la función de curvatura de campana de Gauss correspondiente a la función de densidad de una distribución normal estándar\n\n$$\nf(x) = \\frac{1}{\\sqrt{2\\pi}}e^{-x^2/2}.\n$$\n\n¿En qué puntos la curvatura es nula? ¿Dónde la curvatura es máxima localmente?\n\n:::{.callout-note collapse=\"true\"}\n## Ayuda\nLa [curvatura de la gráfica de una función real](https://aprendeconalf.es/analisis-ejercicios/10-funciones-vectoriales.html#exr-curvatura-funcion) $f(x)$ se calcula mediante la fórmula \n\n$$\n\\kappa(x) = \\frac{|f''(x)|}{(1+f''(x)^2)^{3/2}}.\n$$\n:::\n\n:::{.callout-tip collapse=\"true\"}\n## Solución\n\nDibujamos primero la gráfica de la función y la de la función curvatura.\n\n::: {.cell execution_count=20}\n``` {.julia .cell-code}\nusing SymPy, GLMakie\n@syms x::real\n# Definimos la función.\nf(x) = 1/sqrt(2pi) * exp(-x^2/2)\n# Dibujamos la gráfica de la función.\nfig = Figure()\nax = Axis(fig[1,1], autolimitaspect = 1)\nlines!(ax, -3..3, f, label = L\"$f(t)= \\frac{1}{\\sqrt{2\\pi}}e^{-x^2/2}$\")\nfig\n# Calculamos la segunda derivada de la función.\ndf2 = lambdify(diff(f(x), x, 2))\n# Calculamos la función de curvatura.\nk(x) = abs(df2(x)) / (1 + df2(x)^2)^(3/2)\n# Definimos una serie de puntos de la función curvatura.\nxs = range(-3, 3, 200)\npoints = Point2.(xs, k.(xs))\n# Dibujamos la función de curvatura\nlines!(ax, points, label = \"Curvatura\")\n# Añadimos la leyenda\naxislegend()\nfig\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n![](08-funciones-vectoriales_files/figure-pdf/cell-21-output-1.png){fig-pos='H'}\n:::\n:::\n\n\nAhora calculamos los puntos con curvatura máxima y mínima localmente.\n\n::: {.cell execution_count=21}\n``` {.julia .cell-code}\n# Calculamos los puntos que anulan la curvatura.\nsolve(k(x),x)\n# Calculamos los puntos críticos de la curvatura.\n# solve(diff(k(x)), x) No encuentra la solución, así que buscamos la solución numéricamente.\nusing Roots\nprintln(\"Máximo local en x = $(find_zero(diff(k(x)), -2))\")\nprintln(\"Máximo local en x = $(find_zero(diff(k(x)), 0))\")\nprintln(\"Máximo local en x = $(find_zero(diff(k(x)), 2))\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMáximo local en x = -1.7320508075688772\nMáximo local en x = 0.0\nMáximo local en x = 1.7320508075688772\n```\n:::\n:::\n\n\n:::\n:::\n\n:::{#exr-curvatura-torsion}\nLa _torsión_ de una trayectoria de una función vectorial $\\mathbf{f}(t)$ en el espacio real $\\mathbb{R}^3$ mide la intensidad con la que una curva se sale del plano osculador y se calcula con la fórmula\n\n$$\n\\tau(t) = \\frac{(\\mathbf{f}'(t)\\times \\mathbf{f}''(t))\\mathbf{f}'''(t)}{|\\mathbf{f}'(t)\\times \\mathbf{f}''(t)|^2}\n$$\n\nDefinir una función para la curvatura y y otra para la torsión de la trayectoria de la función vectorial $\\mathbf{h}(t)=\\cos(2t)\\mathbf{i} + \\operatorname{sen}(t) \\mathbf{j} + \\cos(t) \\mathbf{k}$, y utilizarla para calcular la curvatura y la torsión en los instantes $t=0, \\pi/4, \\pi/2, 3\\pi/2$.\n\n:::{.callout-tip collapse=\"true\"}\n## Solución\n\nCalculamos primero la curvatura.\n\n::: {.cell execution_count=22}\n``` {.julia .cell-code}\nusing SymPy, LinearAlgebra\n\"\"\"\n    curvatura(h, a)\n\nCalcula la curvatura de la trayectoria de una función vectorial h en el punto a.\n\"\"\"\nfunction curvatura(f, a)\n    @syms t::real\n    # Calculamos la primera derivada.\n    df(t) = diff.(f(t))\n    # Calculamos la segunda derivada.\n    df2(t) = diff.(df(t))\n    # Calculamos la curvatura\n    k(t) = norm(cross(df(t), df2(t))) / norm(df(t))^3\n    return N(subs(k(t), t=>a))\nend\n\nf(t) = [cos(2t), sin(t), cos(t)]\nprintln(\"Curvatura en t=0: $(curvatura(f, 0))\")\nprintln(\"Curvatura en t=π/4: $(curvatura(f, pi/4))\")\nprintln(\"Curvatura en t=π/2: $(curvatura(f, pi/2))\")\nprintln(\"Curvatura en t=3π/4: $(curvatura(f, 3pi/4))\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCurvatura en t=0: 4.123105625617661\nCurvatura en t=π/4: 0.2\nCurvatura en t=π/2: 4.123105625617661\nCurvatura en t=3π/4: 0.2\n```\n:::\n:::\n\n\nY ahora calculamos la torsión.\n\n::: {.cell execution_count=23}\n``` {.julia .cell-code}\nusing SymPy, LinearAlgebra\n\"\"\"\n    torsion(h, a)\n\nCalcula la torsion de la trayectoria de una función vectorial h en el punto a.\n\"\"\"\nfunction torsion(f, a)\n    @syms t::real\n    # Calculamos la primera derivada.\n    df(t) = diff.(f(t))\n    # Calculamos la segunda derivada.\n    df2(t) = diff.(df(t))\n    # Calculamos la tercera derivada.\n    df3(t) = diff.(df2(t))\n    # Calculamos la torsión.\n    τ(t) = dot(cross(df(t), df2(t)), df3(t)) / norm(cross(df(t), df2(t)))^2\n    return N(subs(τ(t), t=>a))\nend\n\nprintln(\"Torsión en t=0: $(torsion(f, 0))\")\nprintln(\"Torsión en t=π/4: $(torsion(f, pi/4))\")\nprintln(\"Torsión en t=π/2: $(torsion(f, pi/2))\")\nprintln(\"Torsión en t=3π/4: $(torsion(f, 3pi/4))\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTorsión en t=0: 0\nTorsión en t=π/4: -1.2000000000000002\nTorsión en t=π/2: -4.3222828205200695e-17\nTorsión en t=3π/4: 1.2000000000000002\n```\n:::\n:::\n\n\n:::\n:::\n\n:::{#exr-cinematica} \nSe lanza una pelota desde la terraza de un edificio de altura $h$ con una rapidez inicial $r$ y un ángulo sobre el horizonte $\\theta$. Estudiar la trayectoria que describe la pelota suponiendo que la única fuerza que actúa sobre ella es la de la gravedad.\n\na.  Definir una función para calcular la función vectorial de la posición de la pelota tomando como parámetros la altura del edificio, la rapidez inicial y el ángulo de lanzamiento.\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución\n\n\n    ::: {.cell execution_count=24}\n    ``` {.julia .cell-code}\n    using SymPy\n    \"\"\"\n        pelota(h, r, θ)\n    \n    Devuelve un vector con las componentes de la función vectorial que define la posición de una pelota lanzada desde una altura h, con una rapidez r y un ángulo de lanzamiento θ con respecto al horizonte.\n    \"\"\"\n    function pelota(h, r, θ)\n        @syms t::positive\n        # Constante con al aceleración de la gravedad\n        g = 9.81\n        # Posición inicial.\n        p₀ = [0, h] \n        # Velocidad inicial.\n        v₀ = [r*cos(θ), r*sin(θ)]\n        # Aceleración constante\n        a(t) = [Sym(0), -g]\n        # Obtenemos el vector velocidad integrando la aceleración.\n        v(t) = integrate.(a(t), t) + v₀\n        # Obtenemos el vector posición integrando el vector velocidad.\n        pos = integrate.(v(t), t) + p₀\n        return pos\n    end\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=25}\n    ```\n    pelota\n    ```\n    :::\n    :::\n    \n    \n    :::\n\na.  Construir una función para dibujar la gráfica de la trayectoria de la pelota tomando como parámetros la altura del edificio, la rapidez inicial y el ángulo de lanzamiento.\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución\n\n\n    ::: {.cell execution_count=25}\n    ``` {.julia .cell-code}\n    using GLMakie\n    \"\"\"\n        trayectoria_pelota(ax, h, r, θ)\n    \n    Dibuja sobre los ejes ax la gráfica de la trayectoria de una pelota lanzada desde una altura h, con una rapidez r y un ángulo de lanzamiento θ con respecto al horizonte.\n    \"\"\"\n    function trayectoria_pelota!(ax, h, r, θ)\n        @syms t::positive\n        # Lambdificamos la función para poder llamarla con parámetros.\n        f = lambdify(pelota(h, r, θ))\n        # Calculamos el instante en el que la pelota toca el suelo.\n        t₀ = N(solve(f(t)[2], t)[1])\n        # Definimos un rango de valores desde 0 hasta el instante en que la pelota toca el suelo.\n        ts = range(0, t₀, 200)\n        # Obtenemos los puntos de la trayectoria.\n        points = Point2.(f.(ts))\n        # Dibujamos la trayectoria.\n        lines!(ax, points, label = \"h =$(h), r = $(r), θ = $(θ)\")\n        return ax\n    end\n    \n    fig = Figure()\n    ax = Axis(fig[1,1], title = \"Trayectoria de la pelota\", aspect = DataAspect())\n    trayectoria_pelota!(ax, 100, 20, PI/4)\n    trayectoria_pelota!(ax, 100, 20, PI/6)\n    trayectoria_pelota!(ax, 100, 20, PI/8)\n    trayectoria_pelota!(ax, 100, 20, PI/10)\n    # Añadimos la leyenda\n    axislegend(position = :lb)\n    fig\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=26}\n    ![](08-funciones-vectoriales_files/figure-pdf/cell-26-output-1.png){fig-pos='H'}\n    :::\n    :::\n    \n    \n    :::\n\na.  Si se lanza la pelota a nivel del suelo, con una rapidez de 20 m/s ¿para qué ángulo se alcanzará una mayor distancia? ¿Y si se lanza desde 100 m de altura?\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución\n\n    Calculamos primero el ángulo para una altura 0.\n\n\n    ::: {.cell execution_count=26}\n    ``` {.julia .cell-code}\n    @syms θ, t:: positive\n    # Definimos la función vectorial.\n    g(t) = pelota(0, 20, θ)\n    # Calculamos el instante en que la pelota toca el suelo.\n    t₀ = solve(g(t)[2], t)[1]\n    # Calculamos los puntos críticos de la derivada de la posición horizontal de la pelota.\n    solve(diff(subs(g(t)[1], t=>t₀), θ))\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=27}\n    ```{=tex}\n    $\\left[\\begin{smallmatrix}-0.785398163397448\\\\0.785398163397448\\end{smallmatrix}\\right]$\n    ```\n    :::\n    :::\n    \n    \n    Y ahora para una altura de 100 m.\n\n\n    ::: {.cell execution_count=27}\n    ``` {.julia .cell-code}\n    using Roots\n    @syms θ, t:: positive\n    # Definimos la función vectorial.\n    g(t) = pelota(100, 20, θ)\n    # Definimos la función vectorial.\n    t₀ = solve(g(t)[2], t)[2]\n    # Calculamos los puntos críticos de la derivada de la posición horizontal de la pelota.\n    find_zero(diff(subs(g(t)[1], t=>t₀), θ), 0.5)\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=28}\n    ```\n    0.3903970673218906\n    ```\n    :::\n    :::\n    \n    \n    :::\n\na.  Determinar las componentes tangencial y normal del vector aceleración, para una altura de 100 m, una rapidez de 20 m/s y un ángulo $\\pi/4$. Comprobar que la componente tangencial de la aceleración se anula en el mismo instante en el que la componente normal es máxima y cuando la pelota alcanza la máxima altura.\n\n    :::{.callout-note collapse=\"true\"}\n    ## Ayuda\n    La componente tangencial del vector aceleración se puede calcular con la fórmula\n\n    $$\n    a_T(t) = |\\mathbf{v}(t)|' = \\frac{\\mathbf{f}'(t)\\mathbf{f}''(t)}{|\\mathbf{f}'(t)|}.\n    $$\n\n    Y la componente normal mediante la fórmula\n\n    $$\n    a_N(t) = \\kappa(t)|\\mathbf{v}(t)|^2 = \\frac{|\\mathbf{f}'(t)\\times \\mathbf{f}''(t)|}{|\\mathbf{f}'(t)|}.\n    $$\n\n    Si la trayectoria no es en el plano real, se pueden aplicar estas fórmulas añadiendo una tercera componente nula. \n    :::\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución\n\n    Calculamos primero la componente tangencial del vector aceleración.\n\n\n    ::: {.cell execution_count=28}\n    ``` {.julia .cell-code}\n    using LinearAlgebra\n    @syms t::positive\n    # Creamos la función vectorial\n    g(t) = pelota(100, 20, PI/4)\n    # Añadimos una tercera componente nula para estar en el espacio real.\n    g3 = push!(g(t), 0)\n    # Calculamos la primera derivada (vector velocidad).\n    dg = diff.(g3, t)\n    # Calculamos la segunda derivada (vector aceleración).\n    dg2 = diff.(dg, t)\n    # Calculamos la componente tangencial del vector aceleración.\n    at = dot(dg, dg2) / norm(dg)\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=29}\n    ```{=tex}\n    $\\frac{96.2361 t - 98.1 \\sqrt{2}}{\\sqrt{100 \\left(0.981 t - \\sqrt{2}\\right)^{2} + 200}}$\n    ```\n    :::\n    :::\n    \n    \n    Y a continuación la componente normal.\n\n\n    ::: {.cell execution_count=29}\n    ``` {.julia .cell-code}\n    an = norm(cross(dg, dg2)) / norm(dg)\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=30}\n    ```{=tex}\n    $\\frac{138.734350468801}{\\sqrt{100 \\left(0.981 t - \\sqrt{2}\\right)^{2} + 200}}$\n    ```\n    :::\n    :::\n    \n    \n    Ahora calculamos el instante en el que se anula la componente tangencial.\n\n\n    ::: {.cell execution_count=30}\n    ``` {.julia .cell-code}\n    solve(at)\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=31}\n    ```{=tex}\n    $\\left[\\begin{smallmatrix}1.4416040391163\\end{smallmatrix}\\right]$\n    ```\n    :::\n    :::\n    \n    \n    Finalmente comprobamos que es el mismo instante en el que la componente normal de la aceleración es máxima.\n\n\n    ::: {.cell execution_count=31}\n    ``` {.julia .cell-code}\n    # Instante en el que la componente normal de la acelaración es máxima.\n    solve(diff(an))\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=32}\n    ```{=tex}\n    $\\left[\\begin{smallmatrix}1.4416040391163\\end{smallmatrix}\\right]$\n    ```\n    :::\n    :::\n    \n    \n    Y comprobamos también que  coincide con el instante en que la pelota alcanza la máxima altura.\n\n\n    ::: {.cell execution_count=32}\n    ``` {.julia .cell-code}\n    solve(diff(g(t)[2]))\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=33}\n    ```{=tex}\n    $\\left[\\begin{smallmatrix}1.4416040391163\\end{smallmatrix}\\right]$\n    ```\n    :::\n    :::\n    \n    \n    :::\n:::\n\n## Ejercicios propuestos\n\n\n:::{#exr-funciones-vectoriales-propuesto-1}\nCalcular el módulo del producto vectorial de los vectores $(-\\pi,\\sqrt{2},1)$ y $(\\sqrt{3},-e,-2)$. \n\n::: {.cell hold='true' execution_count=34}\n\n::: {.cell-output .cell-output-display execution_count=35}\n```{=tex}\n\\vspace{18pt}*Hint: *\n\nIntroducir hasta 5 decimales\n\n```\n:::\n:::\n\n\n:::\n\n:::{#exr-funciones-vectoriales-propuesto-2}\n¿A qué función vectorial le corresponde la trayectoria siguiente?\n\n::: {.cell execution_count=35}\n\n::: {.cell-output .cell-output-display execution_count=36}\n![](08-funciones-vectoriales_files/figure-pdf/cell-36-output-1.png){}\n:::\n:::\n\n\n::: {.cell hold='true' execution_count=36}\n\n::: {.cell-output .cell-output-display execution_count=37}\n```{=tex}\n${\\quad\\Box}$ $$f(t)=(\\cos(2t), \\cos(t)/2, \\operatorname{sen}(t/2))$$\n${\\quad\\Box}$ $$f(t)=(\\operatorname{sen}(t)/2, \\cos(2t), \\cos(t))$$\n${\\quad\\Box}$ $$f(t)=(\\operatorname{sen}(2t), \\cos(t)/2, \\operatorname{sen}(t))$$\n${\\quad\\Box}$ $$f(t)=(\\operatorname{sen}(t), \\cos(2t), \\cos(t)/2)$$\n${\\quad\\Box}$ Las otras opciones son falsas.\n\n```\n:::\n:::\n\n\n:::\n\n:::{#exr-funciones-vectoriales-propuesto-3}\nUn mosquito sigue la trayectoria de la función $f(t)=(\\cos(t), t/2, \\ln(t+1))$. Si en el instante $t=1$ se sale por la tangente a la trayectoria, ¿a qué distancia del origen de coordenadas estará el mosquito en el instante $t=2$?\n\n::: {.cell execution_count=37}\n\n::: {.cell-output .cell-output-display execution_count=38}\n```{=tex}\n\\vspace{18pt}*Hint: *\n\nIntroducir hasta 5 decimales\n\n```\n:::\n:::\n\n\n:::\n\n:::{#exr-funciones-vectoriales-propuesto-4}\n¿Cuál de las siguientes ecuaciones es la del plano normal a la trayectoria de la función $g(t)=(\\cos(t-1), \\ln(\\sqrt{t}), t^2)$ en el instante $t=1$?\n\n::: {.cell execution_count=38}\n\n::: {.cell-output .cell-output-display execution_count=39}\n```{=tex}\n${\\quad\\Box}$ $$x+\\frac{1}{2}y-z=0$$\n${\\quad\\Box}$ $$2x-z=1$$\n${\\quad\\Box}$ $$\\frac{1}{4}y-z=1$$\n${\\quad\\Box}$ $$x+y+z=2$$\n${\\quad\\Box}$ Las otras opciones son falsas.\n\n```\n:::\n:::\n\n\n:::\n\n:::{#exr-funciones-vectoriales-propuesto-5}\nUn avión sigue la trayectoria de la función $h(t)=(2t^2+t, \\operatorname{sen}(t)+2cos(t), e^{-t/2})$. \n\na.  ¿Qué distancia habrá recorrido desde instante $t=1$ hasta el instante $t=5$?\n\n\n    ::: {.cell execution_count=39}\n    \n    ::: {.cell-output .cell-output-display execution_count=40}\n    ```{=tex}\n    \\vspace{18pt}*Hint: *\n    \n    Introducir hasta 5 decimales\n    \n    ```\n    :::\n    :::\n    \n    \na.  ¿Cuál será la curvatura de la trayectoria en el instante $t=2$?\n\n\n    ::: {.cell execution_count=40}\n    \n    ::: {.cell-output .cell-output-display execution_count=41}\n    ```{=tex}\n    \\vspace{18pt}*Hint: *\n    \n    Introducir hasta 5 decimales\n    \n    ```\n    :::\n    :::\n    \n    \na.  ¿Cuál será la torsión de la trayectoria en el instante $t=2$?\n\n\n    ::: {.cell execution_count=41}\n    \n    ::: {.cell-output .cell-output-display execution_count=42}\n    ```{=tex}\n    \\vspace{18pt}*Hint: *\n    \n    Introducir hasta 5 decimales\n    \n    ```\n    :::\n    :::\n    \n    \n:::\n\n:::{#exr-funciones-vectoriales-propuesto-6}\nUn coche circula por una circuito elíptico cuya trayectoria viene dada por la función vectorial $f(t)=(400\\cos(10t), 100\\operatorname{sen}(10t))$, donde $t$ está dado en minutos y las coordenadas de $f$ en metros.\n\na.  Calcular la rapidez del vehículo en el instante $t=\\pi$.\n\n\n    ::: {.cell execution_count=42}\n    \n    ::: {.cell-output .cell-output-display execution_count=43}\n    ```{=tex}\n    \\vspace{18pt}*Hint: *\n    \n    Introducir hasta 5 decimales\n    \n    ```\n    :::\n    :::\n    \n    \na.  Calcular el módulo del vector aceleración en el mismo instante.\n\n\n    ::: {.cell execution_count=43}\n    \n    ::: {.cell-output .cell-output-display execution_count=44}\n    ```{=tex}\n    \\vspace{18pt}*Hint: *\n    \n    Introducir hasta 5 decimales\n    \n    ```\n    :::\n    :::\n    \n    \na.  Calcular la componente tangencial del vector aceleración en ese instante.\n\n\n    ::: {.cell execution_count=44}\n    \n    ::: {.cell-output .cell-output-display execution_count=45}\n    ```{=tex}\n    \\vspace{18pt}*Hint: *\n    \n    Introducir hasta 5 decimales\n    \n    ```\n    :::\n    :::\n    \n    \na.  Calcular la componente normal del vector aceleración en ese instante.\n\n\n    ::: {.cell execution_count=45}\n    \n    ::: {.cell-output .cell-output-display execution_count=46}\n    ```{=tex}\n    \\vspace{18pt}*Hint: *\n    \n    Introducir hasta 5 decimales\n    \n    ```\n    :::\n    :::\n    \n    \na.  Suponiendo que los neumáticos no proporcionan ningún agarre (por ejemplo porque hay hielo en la carretera), ¿Cuál es el mínimo ángulo que debería tener el peralte de la curva en este instante para que el coche no se salga del circuito? Tómese una aceleración debida a la gravedad de $9.8$ m/s$^2$.\n\n\n    ::: {.cell execution_count=46}\n    \n    ::: {.cell-output .cell-output-display execution_count=47}\n    ```{=tex}\n    \\vspace{18pt}*Hint: *\n    \n    Introducir hasta 5 decimales\n    \n    ```\n    :::\n    :::\n    \n    \n:::\n\n",
    "supporting": [
      "08-funciones-vectoriales_files/figure-pdf"
    ],
    "filters": []
  }
}