{
  "hash": "d4c1dff5ad395d3ad22d6849a05ad53f",
  "result": {
    "markdown": "---\ntitle: Funciones vectoriales\nlang: es\n#jupyter: julia-1.9\n---\n\n## Ejercicios Resueltos\n\nPara la realización de esta práctica se requieren los siguientes paquetes:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing SymPy  # Para el cálculo simbólico.\nusing Plots  # Para el dibujo de gráficas.\nusing Makie, GLMakie # Para el dibújo de gráficas en 3d.\n#plotlyjs() # Para obtener gráficos interactivos.\nusing LaTeXStrings  # Para usar código LaTeX en los gráficos.\nusing LinearAlgebra # Para el módulo, producto escalar y vectorial de vectores.\nusing Roots # Para calcular soluciones de ecuaciones numéricamente.\nusing CalculusWithJulia # Utilidades para dibujar vectores.\n```\n:::\n\n\n:::{#exr-vectores}\nRepresentar gráficamente los vectores $\\mathbf{u}=(3,1)$, $\\mathbf{v}=(1,2)$ y $\\mathbf{u}-\\mathbf{v}$ en el plano real $\\mathbb{R}^2$.\n\n:::{.callout-note collapse=\"true\"}\n## Ayuda\nUsar la función [`arrow`](https://docs.juliahub.com/CalculusWithJulia/AZHbv/0.1.2/#CalculusWithJulia.arrow-Tuple) del paquete `CalculusWithJulia` para dibujar flechas que representan vectores.\n:::\n\n:::{.callout-tip collapse=\"true\"}\n## Solución\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nusing CalculusWithJulia\nusing LaTeXStrings\nO = [0, 0] # Origin\nu = [3, 1]\nv = [1, 2]\nPlots.plot()\narrow!(O, u)\narrow!(O, v)\narrow!(v, u-v)\nannotate!(1.5, 0.4, L\"$\\mathbf{u}$\")\nannotate!(0.4, 1, L\"$\\mathbf{v}$\")\nannotate!(2.1, 1.6, L\"$\\mathbf{u}-\\mathbf{v}$\")\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n![](08-funciones-vectoriales_files/figure-pdf/cell-3-output-1.svg){fig-pos='H'}\n:::\n:::\n\n\n:::\n:::\n\n:::{#exr-producto-escalar-vectorial}\nSean $\\mathbf{u}=(1,2,-1)$ y $\\mathbf{v}=(3,0,2)$ dos vectores del espacio real $\\mathbb{R}^3$.\n\na.  Calcular el módulo (norma) de ambos vectores y construir vectores unitarios con su misma dirección.\n\n    :::{.callout-note collapse=\"true\"}\n    ## Ayuda\n    Usar la función [`norm`](https://aprendeconalf.es/manual-julia/tipos-datos-compuestos.html#%C3%A1lgebra-lineal-con-vectores) del paquete `LinearAlgebra` para calular el módulo de un vector.\n    :::\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución\n\n\n    ::: {.cell execution_count=3}\n    ``` {.julia .cell-code}\n    using LinearAlgebra\n    u = [-1, 2, -1]\n    v = [-2, 0, 1]\n    println(\"Módulo de u: $(norm(u))\")\n    println(\"Módulo de v: $(norm(v))\")\n    println(\"Vector unitario con la dirección de u $(u/norm(u))\")\n    println(\"Vector unitario con la dirección de v $(v/norm(v))\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    Módulo de u: 2.449489742783178\n    Módulo de v: 2.23606797749979\n    Vector unitario con la dirección de u [-0.4082482904638631, 0.8164965809277261, -0.4082482904638631]\n    Vector unitario con la dirección de v [-0.8944271909999159, 0.0, 0.4472135954999579]\n    ```\n    :::\n    :::\n    \n    \n    :::\n\na.  Calcular su producto escalar.\n\n    :::{.callout-note collapse=\"true\"}\n    ## Ayuda\n    Usar la función [`dot`](https://aprendeconalf.es/manual-julia/tipos-datos-compuestos.html#%C3%A1lgebra-lineal-con-vectores) del paquete `LinearAlgebra` para calcular el producto escalar de dos vectores.\n    :::\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución\n\n\n    ::: {.cell execution_count=4}\n    ``` {.julia .cell-code}\n    println(\"Producto escalar de u y v $(dot(u, v))\")\n    # También se puede usar el clásico punto ⋅\n    println(\"Producto escalar de u y v $(u ⋅ v)\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    Producto escalar de u y v 1\n    Producto escalar de u y v 1\n    ```\n    :::\n    :::\n    \n    \n    :::\n\na.  Calcular su producto vectorial.\n\n    :::{.callout-note collapse=\"true\"}\n    ## Ayuda\n    Usar la función [`cross`](https://aprendeconalf.es/manual-julia/tipos-datos-compuestos.html#%C3%A1lgebra-lineal-con-vectores) del paquete `LinearAlgebra` para calcular el producto vectorial de dos vectores.\n    :::\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución\n\n\n    ::: {.cell execution_count=5}\n    ``` {.julia .cell-code}\n    println(\"Producto vectorial de u y v $(cross(u, v))\")\n    # También se puede usar la clásica cruz × \n    println(\"Producto vectorial de u y v $(u × v)\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    Producto vectorial de u y v [2, 3, 4]\n    Producto vectorial de u y v [2, 3, 4]\n    ```\n    :::\n    :::\n    \n    \n    :::\n\na.  Dibujar $\\mathbf{u}$, $\\mathbf{v}$ y $\\mathbf{u}\\times\\mathbf{v}$ en el espacio real.\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución 1\n    Usando el paquete `Plots`.\n\n\n    ::: {.cell execution_count=6}\n    ``` {.julia .cell-code}\n    using CalculusWithJulia\n    Plots.plot(xlabel = \"X\", ylabel = \"Y\", zlabel = \"Z\", legend = false)\n    O = [0, 0 ,0]\n    arrow!(O, u)\n    arrow!(O, v)\n    arrow!(O, u × v)\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=7}\n    ![](08-funciones-vectoriales_files/figure-pdf/cell-7-output-1.svg){fig-pos='H'}\n    :::\n    :::\n    \n    \n    :::\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución 2\n    Usando el paquete `Makie`.\n\n\n    ::: {.cell execution_count=7}\n    ``` {.julia .cell-code}\n    using GLMakie\n    fig = Figure()\n    ax = Axis3(fig[1,1], azimuth = -pi/4, aspect = (1,1,1))\n    O = [0, 0 ,0]\n    arrows!(ax, [Point3(O)], [Vec3(u), Vec3(v), Vec3(u × v)], \n        linecolor = [:blue,:red, :green], arrowcolor = [:blue,:red, :green],\n        linewidth = 0.02, arrowsize = Vec3(0.1, 0.1, 0.1),\n        align = :origin)\n    fig\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=8}\n    ![](08-funciones-vectoriales_files/figure-pdf/cell-8-output-1.png){fig-pos='H'}\n    :::\n    :::\n    \n    \n    :::\n:::\n\n:::{#exr-grafica-trayectorias}\nDibujar las trayectorias de las siguientes funciones vectoriales.\n\na.  $f(t)=(\\operatorname{sen}(t), \\cos(t))$.\n\n    :::{.callout-note collapse=\"true\"}\n    ## Ayuda\n    Usar la función [`plot`](https://aprendeconalf.es/manual-julia/graficos.html#gr%C3%A1fica-de-una-funci%C3%B3n-de-una-variable) del paquete `Plots`  o la función `lines` del paquete `Makie` para dibujar la trayectoria, pasándole cada una de las funciones componentes separadas por comas.\n    :::\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución 1\n\n    Usando el paquete `Plots`.\n\n\n    ::: {.cell execution_count=8}\n    ``` {.julia .cell-code}\n    using Plots\n    using CalculusWithJulia\n    f(t) = [sin(t), cos(t)] \n    ts = range(0, 2pi, length = 200)\n    xs, ys = unzip(f.(ts))\n    Plots.plot(xs, ys, aspect_ratio = :equal)\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=9}\n    ![](08-funciones-vectoriales_files/figure-pdf/cell-9-output-1.svg){fig-pos='H'}\n    :::\n    :::\n    \n    \n    :::\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución 2\n\n    Usando el paquete `Makie`.\n\n\n    ::: {.cell execution_count=9}\n    ``` {.julia .cell-code}\n    using GLMakie\n    f(t) = [sin(t), cos(t)] \n    ts = range(0, 2pi, length = 200)\n    points = Point2.(f.(ts))\n    fig = Figure()\n    ax = Axis(fig[1,1], aspect = 1)\n    lines!(ax, points, linewidth = 2, color = :blue)\n    fig\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=10}\n    ![](08-funciones-vectoriales_files/figure-pdf/cell-10-output-1.png){fig-pos='H'}\n    :::\n    :::\n    \n    \n    :::\n\na.  $\\mathbf{g}(t) = (\\cos(t), \\operatorname{sen}(t), t/4)$.\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución 1\n\n    Usando el paquete `Plots`.\n\n\n    ::: {.cell execution_count=10}\n    ``` {.julia .cell-code}\n    g(t) = [cos(t), sin(t), t/4] \n    ts = range(0, 2pi, length = 200)\n    xs, ys, zs = unzip(g.(ts))\n    Plots.plot(xs, ys, zs, aspect_ratio = :equal, xlabel = \"X\", ylabel = \"Y\", zlabel = \"Z\", label = \"\")\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=11}\n    ![](08-funciones-vectoriales_files/figure-pdf/cell-11-output-1.svg){fig-pos='H'}\n    :::\n    :::\n    \n    \n    :::\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución 2\n\n    Usando el paquete `Makie`.\n\n\n    ::: {.cell execution_count=11}\n    ``` {.julia .cell-code}\n    using GLMakie\n    g(t) = [cos(t), sin(t), t/4] \n    ts = range(0, 2pi, length = 200)\n    points = Point3.(g.(ts))\n    fig = Figure()\n    ax = Axis3(fig[1,1])\n    lines!(ax, points, linewidth = 2, color = :blue)\n    fig\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=12}\n    ![](08-funciones-vectoriales_files/figure-pdf/cell-12-output-1.png){fig-pos='H'}\n    :::\n    :::\n    \n    \n    :::\n:::\n\n:::{#exr-nudos-toricos}\nUn [nudo tórico](https://en.wikipedia.org/wiki/Torus_knot) es un nudo que se forma mediante una trayectoria que gira sobre la superficie de un toro en $\\mathbb{R}^3$. La función vectorial que define este tipo de nudos sobre un toro de ecuación $(r-2)^2+z^2 = 1$ es $\\mathbf{f}(t) = ((2+\\cos(qt))\\cos(pt), (2+\\cos(qt))\\operatorname{sen}(pt), -\\operatorname{sen}(qt))$, donde $p$ y $q$ son dos enteros primos entre si y $t\\in [0,2\\pi]$.\n\na.  Dibujar el nudo tórico  con $p=2$ y $q=3$.\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución\n\n    Usando el paquete `Makie`.\n\n\n    ::: {.cell execution_count=12}\n    ``` {.julia .cell-code}\n    using GLMakie\n    # Definimos las ecuaciones paramétricas del toro.\n    U = LinRange(-pi, pi, 100)\n    V = LinRange(-pi, pi, 20)\n    x1 = [2cos(u) + cos(u) * cos(v) for u in U, v in V]\n    y1 = [2sin(u) + sin(u) * cos(v) for u in U, v in V]\n    z1 = [sin(v) for u in U, v in V]\n    # Inicializamos la figura y los ejes.\n    fig = Figure()\n    ax = Axis3(fig[1,1], aspect = (3, 3, 1))\n    # Dibujamos el toro.\n    Makie.surface!(ax, x1, y1, z1; colormap = :viridis, shading = false, transparency = true, alpha = 0.5)\n    # Definimos la función vectorial de nudo tórico.\n    f(t) = [(2+cos(3t))cos(2t), (2+cos(3t))sin(2t), -sin(3t)] \n    # Generamos los puntos de la trayectoria del nudo tórico.\n    ts = range(0, 2pi, length = 200)\n    points = Point3.(f.(ts))\n    # Dibujamos el nudo tórico.\n    lines!(ax, points, linewidth = 3, color = :red)\n    fig\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=13}\n    ![](08-funciones-vectoriales_files/figure-pdf/cell-13-output-1.png){fig-pos='H'}\n    :::\n    :::\n    \n    \n    :::\n\na.  Definir una función para crear nudos tóricos con parámetros `p` y `q` para los enteros que definen el toro y un parámetro opcional booleano `toro`, para dibujar el toro o no.\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución\n\n\n    ::: {.cell execution_count=13}\n    ``` {.julia .cell-code}\n    using GLMakie\n    \"\"\"\n        nudo_torico(ax, p, q, toro)\n    \n    Función dibuja un nudo tórico de parámetros p, q sobre los ejes ax. Si el parámetro toro es true dibuja también el toro sobre el que se traza el nudo.\n    \"\"\"\n    function nudo_torico(ax::Axis3, p::Int64, q::Int64, toro::Bool = true)\n        if toro \n            alpha = 0.5\n        else\n            alpha = 0\n        end\n        # Definimos las ecuaciones paramétricas del toro.\n        U = LinRange(-pi, pi, 100)\n        V = LinRange(-pi, pi, 20)\n        x1 = [2cos(u) + cos(u) * cos(v) for u in U, v in V]\n        y1 = [2sin(u) + sin(u) * cos(v) for u in U, v in V]\n        z1 = [sin(v) for u in U, v in V]\n        # Inicializamos la figura y los ejes.\n        #fig = Figure()\n        #ax = Axis3(fig[1,1], show_axis = true)\n        # Dibujamos el toro.\n        Makie.surface!(ax, x1, y1, z1; colormap = :viridis, shading = false, transparency = true, alpha = alpha)\n        # Definimos la función vectorial de nudo tórico.\n        f(t) = [(2+cos(q*t))cos(p*t), (2+cos(q*t))sin(p*t), -sin(q*t)] \n        # Generamos los puntos de la trayectoria del nudo tórico.\n        ts = range(0, 2pi, length = 200)\n        points = Point3.(f.(ts))\n        # Dibujamos el nudo tórico.\n        lines!(ax, points, linewidth = 3, color = :red)\n    end\n    \n    fig = Figure()\n    ax = Axis3(fig[1,1], aspect = (3, 3, 1))\n    nudo_torico(ax, 5, 9, true)\n    fig\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=14}\n    ![](08-funciones-vectoriales_files/figure-pdf/cell-14-output-1.png){fig-pos='H'}\n    :::\n    :::\n    \n    \n    :::\n:::\n\n:::{#exr-tangente-normal}\na.  Calcular las ecuaciones de la recta tangente y el plano normal a la trayectoria $\\mathbf{f}(t) = (\\operatorname{sen}(2t), \\cos(t))$ en el punto correspondiente a $t=\\pi/2$ y dibujarlas.\n\n    :::{.callout-note collapse=\"true\"}\n    ## Ayuda\n    La ecuación de la recta tangente a la trayectoria de la función vectorial $\\mathbf{f}(t)$ en el instante $t=a$ es $\\mathbf{f}(a)+\\mathbf{f}'(a)t$.\n    :::\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución\n\n\n    ::: {.cell execution_count=14}\n    ``` {.julia .cell-code}\n    using SymPy, Plots\n    @syms t::real\n    # Definimos la función vectorial\n    f(t) = [sin(2t), cos(t)]\n    # Instante \n    a = pi/2\n    # Dibujamos la trayectoria\n    Plots.plot(f(t)..., 0, 2pi, aspect_ratio = :equal, label = \"f(t)=(sen(t), cos(t))\")\n    # Dibujamos el punto de tangencia\n    Plots.scatter!([f(a)[1]],[f(a)[2]], label = \"\")\n    # Calculamos la derivada en el punto.\n    df = subs.(diff.(f(t)), t=>a)\n    # Calculamos la ecuación de la recta tangente.\n    tl(t) = f(a) + df * t\n    # Dibujamos la recta tangente.\n    Plots.plot!(tl(t)..., -1, 1, label = \"Tangente\")\n    # Calculamos la ecuación de la recta normal\n    nl(t) = f(a) - [df[2],-df[1]] * t\n    Plots.plot!(nl(t)..., -0.6, 0.6, label = \"Normal\")\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=15}\n    ![](08-funciones-vectoriales_files/figure-pdf/cell-15-output-1.svg){fig-pos='H'}\n    :::\n    :::\n    \n    \n    :::\n\na.  Calcular las ecuaciones de las recta tangente y el plano normal a la trayectoria $\\mathbf{g}(t) = (\\cos(t), \\operatorname{sen}(t), \\sqrt{t})$ en punto correspondiente a $t=\\pi$ y dibujarlas.\n\n    :::{.callout-tip collapse=\"true\"}\n    ## Solución\n\n\n    ::: {.cell execution_count=15}\n    ``` {.julia .cell-code}\n    using SymPy, LinearAlgebra, GLMakie\n    @syms x, y, z, t::real\n    # Definimos la función vectorial\n    g(t) = [cos(t), sin(t), sqrt(t)]\n    # Instante \n    a = pi/2\n    # Dibujamos la trayectoria\n    ts = range(0, 2pi, 200)\n    points = Point3.(g.(ts))\n    fig = Figure()\n    ax = Axis3(fig[1,1], title = \"Recta tangente y plano normal a una trayectoria\", aspect = :equal)\n    lines!(ax, points)\n    # Dibujamos el punto de tangencia.\n    Makie.scatter!([Point3(g(a))])\n    # Calculamos la derivada en el punto.\n    dg = subs.(diff.(g(t)), t=>a)\n    # Calculamos la ecuación de la recta tangente.\n    tl(t) = g(a) + dg * t\n    # Dibujamos la recta tangente.\n    pointstl = Point3.(tl.(range(-pi, pi, 2)))\n    lines!(ax, pointstl)\n    # Calculamos la ecuación del plano normal\n    np(x,y) = solve(dot(([x, y, z] - g(a)),dg), z)[1]\n    xs = range(-1, 1, 2)\n    ys = range(0, 2, 2)\n    zs = [np(x,y) for x in xs, y in ys]\n    Makie.surface!(ax, xs, ys, zs, colormap = [\"red\"], alpha = 0.5, transparency = true)\n    fig\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=16}\n    ![](08-funciones-vectoriales_files/figure-pdf/cell-16-output-1.png){fig-pos='H'}\n    :::\n    :::\n    \n    \n    :::\n:::\n\n:::{#exr-plano-osculador}\nDada una función vectorial $\\mathbf{f}(t)$ en $\\mathbb{R}^3$, el _plano osculador_ de la trayectoria de $\\mathbf{f}(t)$ en $t=a$ es el plano definido por los vectores tangente $\\mathbf{T}(a)$ y normal $\\mathbf{N}(a)$. \n\nCalcular y dibujar el plano osculador de la función vectorial del nudo tórico del apartado a del ejercicio @exr-nudos-toricos en el punto correspondiente a $t=\\pi/2$.\n\n:::{.callout-tip collapse=\"true\"}\n## Solución\n\nUsando el paquete `Makie`.\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\nusing SymPy, LinearAlgebra, GLMakie\n@syms x, y, z, t::real\n# Definimos las ecuaciones paramétricas del toro.\nU = LinRange(-pi, pi, 100)\nV = LinRange(-pi, pi, 20)\nx1 = [2cos(u) + cos(u) * cos(v) for u in U, v in V]\ny1 = [2sin(u) + sin(u) * cos(v) for u in U, v in V]\nz1 = [sin(v) for u in U, v in V]\n# Inicializamos la figura y los ejes.\nfig = Figure()\nax = Axis3(fig[1,1], aspect = (3, 3, 1))\n# Dibujamos el toro.\nMakie.surface!(ax, x1, y1, z1; colormap = :viridis, shading = false, transparency = true, alpha = 0.5)\n# Definimos la función vectorial de nudo tórico.\nf(t) = [(2+cos(3t))cos(2t), (2+cos(3t))sin(2t), -sin(3t)] \n# Generamos los puntos de la trayectoria del nudo tórico.\nts = range(0, 2pi, length = 200)\npoints = Point3.(f.(ts))\n# Dibujamos el nudo tórico.\nlines!(ax, points, linewidth = 3, color = :red)\n# Punto\na = pi/2\n# Dibujamos el punto\nMakie.scatter!(ax, [Point3(f(a))])\n# Vector tangente unitario\nTan(t) = diff.(f(t)) / norm(diff.(f(t)))\nTa = subs.(Tan(t), t=>a)\n# Vector normal unitario\nNorm(t) = diff.(Tan(t)) / norm(diff.(Tan(t)))\nNa = subs.(Norm(t), t=>a)\n# Calculamos la ecuación del plano osculador\npo(x,y) = solve(dot(([x, y, z] - f(a)), cross(Ta, Na)), z)[1]\nxs = range(-3, -1, 2)\nys = range(-1, 1, 2)\nzs = [po(x,y) for x in xs, y in ys]\nMakie.surface!(ax, xs, ys, zs, colormap = [\"magenta\"], alpha = 0.8, transparency = true)\nfig\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n![](08-funciones-vectoriales_files/figure-pdf/cell-17-output-1.png){fig-pos='H'}\n:::\n:::\n\n\n:::\n:::\n\n:::{#exr-longitud-trayectoria}\nPara construir un cuaderno de 30 cm de altura se utiliza una espiral de alambre con radio 1 cm y una distancia entre cada dos vueltas consecutivas $\\pi/4$ cm. Dibujar la espiral y calcular la cantidad de alambre necesaria para cada cuaderno.\n\n:::{.callout-note collapse=\"true\"}\n## Ayuda\nLa [longitud de la trayectoria de una función vectorial](https://aprendeconalf.es/analisis-manual/12-funciones-vectoriales.html#longitud-de-la-trayectoria-de-una-funci%C3%B3n-vectorial) $\\mathbf{fe}(t)$ en el intervalo $t\\in [a,b]$ se calcula mediante la integral\n\n$$\n\\int_a^b |\\mathbf{f}'(t)|\\, dt\n$$\n:::\n\n:::{.callout-tip collapse=\"true\"}\n## Solución\nDibujamos primero la espiral.\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\nusing SymPy, GLMakie\n@syms t::real\n# Definimos la función vectorial\nf(t) = [cos(t), sin(t), t/8]\n# Calculamos el número de revoluciones\nh = solve(f(t)[3]-30)[1]\n# Dibujamos la trayectoria\nts = range(0, 240, 2000)\npoints = Point3.(f.(ts))\nfig = Figure()\nax = Axis3(fig[1,1], title = \"Espiral de un cuaderno\", aspect = (1, 1, 30))\nlines!(ax, points)\nfig\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n![](08-funciones-vectoriales_files/figure-pdf/cell-18-output-1.png){fig-pos='H'}\n:::\n:::\n\n\nA continuación calculamos la longitud de la espiral.\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\nusing LinearAlgebra\n# Calculamos la derivada en el punto.\nN(integrate(norm(diff.(f(t))), 0, h))\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n241.8677324489564895709983969091131339340318891682572016380977716779162485307713\n```\n:::\n:::\n\n\n:::\n:::\n\n:::{#exr-curvatura}\nDibujar función de curvatura de campana de Gauss correspondiente a la función de densidad de una distribución normal estándar\n\n$$\nf(x) = \\frac{1}{\\sqrt{2\\pi}}e^{-x^2/2}.\n$$\n\n¿En qué puntos la curvatura es nula? ¿Dónde la curvatura es máxima localmente?\n\n:::{.callout-note collapse=\"true\"}\n## Ayuda\nLa [curvatura de la gráfica de una función real](https://aprendeconalf.es/analisis-ejercicios/10-funciones-vectoriales.html#exr-curvatura-funcion) $f(x)$ se calcula mediante la fórmula \n\n$$\n\\kappa(x) = \\frac{|f''(x)|}{(1+f''(x)^2)^{3/2}}.\n$$\n:::\n\n:::{.callout-tip collapse=\"true\"}\n## Solución\n\nDibujamos primero la gráfica de la función y la de la función curvatura.\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\nusing SymPy, GLMakie\n@syms x::real\n# Definimos la función \nf(x) = 1/sqrt(2pi) * exp(-x^2/2)\n# Dibujamos la gráfica de la función\nfig = Figure()\nax = Axis(fig[1,1], autolimitaspect = 1)\nlines!(ax, -3..3, f, label = L\"$f(t)= \\frac{1}{\\sqrt{2\\pi}}e^{-x^2/2}$\")\nfig\n# Calculamos la segunda derivada de la función\ndf2 = diff(f, 2)\n# Calculamos la función de curvatura\nk(x) = abs(df2(x)) / (1 + df2(x)^2)^(3/2)\n# Definimos una serie de puntos de la función curvatura\nxs = range(-3, 3, 200)\npoints = Point2.(xs, k.(xs))\n# Dibujamos la función de curvatura\nlines!(ax, points, label = \"Curvatura\")\n# Añadimos la leyenda\naxislegend()\nfig\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n![](08-funciones-vectoriales_files/figure-pdf/cell-20-output-1.png){fig-pos='H'}\n:::\n:::\n\n\nAhora calculamos los puntos con curvatura máxima y mínima localmente.\n\n::: {.cell execution_count=20}\n``` {.julia .cell-code}\n# Calculamos los puntos que anulan la curvatura.\nsolve(k(x),x)\n# Calculamos los puntos críticos de la curvatura.\n# solve(diff(k(x)), x) No encuentra la solución, así que buscamos la solución numéricamente.\nusing Roots\nprintln(\"Máximo local en x = $(find_zero(diff(k(x)), -2))\")\nprintln(\"Máximo local en x = $(find_zero(diff(k(x)), 0))\")\nprintln(\"Máximo local en x = $(find_zero(diff(k(x)), 2))\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMáximo local en x = -1.7320508075688774\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nMáximo local en x = 0.0\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nMáximo local en x = 1.7320508075688774\n```\n:::\n:::\n\n\n:::\n:::\n\n:::{#exr-curvatura-torsion}\nLa _torsión_ de una trayectoria de una función vectorial $\\mathbf{f}(t)$ en el espacio real $\\mathbb{R}^3$ mide la intensidad con la que una curva se sale del plano osculador y se calcula con la fórmula\n\n$$\n\\tau(t) = \\frac{(\\mathbf{f}'(t)\\times \\mathbf{f}''(t))\\mathbf{f}'''(t)}{|\\mathbf{f}'(t)\\times \\mathbf{f}''(t)|^2}\n$$\n\nDefinir una función para la curvatura y y otra para la torsión de la trayectoria de la función vectorial $\\mathbf{h}(t)=\\cos(2t)\\mathbf{i} + \\operatorname{sen}(t) \\mathbf{j} + \\cos(t) \\mathbf{k}$, y utilizarla para calcular la curvatura y la torsión en los instantes $t=0, \\pi/4, \\pi/2, 3\\pi/2$.\n\n:::{.callout-tip collapse=\"true\"}\n## Solución\n\nCalculamos primero la curvatura.\n\n::: {.cell execution_count=21}\n``` {.julia .cell-code}\nusing SymPy, LinearAlgebra\n\"\"\"\n    curvatura(h, a)\n\nCalcula la curvatura de la trayectoria de una función vectorial h en el punto a.\n\"\"\"\nfunction curvatura(f, a)\n    @syms t::real\n    # Calculamos la primera derivada.\n    df(t) = diff.(f(t))\n    # Calculamos la segunda derivada.\n    df2(t) = diff.(df(t))\n    # Calculamos la curvatura\n    k(t) = norm(cross(df(t), df2(t))) / norm(df(t))^3\n    return N(subs(k(t), t=>a))\nend\n\nf(t) = [cos(2t), sin(t), cos(t)]\nprintln(\"Curvatura en t=0: $(curvatura(f, 0))\")\nprintln(\"Curvatura en t=π/4: $(curvatura(f, pi/4))\")\nprintln(\"Curvatura en t=π/2: $(curvatura(f, pi/2))\")\nprintln(\"Curvatura en t=3π/4: $(curvatura(f, 3pi/4))\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCurvatura en t=0: 4.123105625617660549821409855974077025147199225373620434398633573094954346337596\nCurvatura en t=π/4: 0.2\nCurvatura en t=π/2: 4.123105625617661\nCurvatura en t=3π/4: 0.2\n```\n:::\n:::\n\n\nY ahora calculamos la torsión.\n\n::: {.cell execution_count=22}\n``` {.julia .cell-code}\nusing SymPy, LinearAlgebra\n\"\"\"\n    torsion(h, a)\n\nCalcula la torsion de la trayectoria de una función vectorial h en el punto a.\n\"\"\"\nfunction torsion(f, a)\n    @syms t::real\n    # Calculamos la primera derivada.\n    df(t) = diff.(f(t))\n    # Calculamos la segunda derivada.\n    df2(t) = diff.(df(t))\n    # Calculamos la tercera derivada.\n    df3(t) = diff.(df2(t))\n    # Calculamos la torsión.\n    τ(t) = dot(cross(df(t), df2(t)), df3(t)) / norm(cross(df(t), df2(t)))^2\n    return N(subs(τ(t), t=>a))\nend\n\nprintln(\"Torsión en t=0: $(torsion(f, 0))\")\nprintln(\"Torsión en t=π/4: $(torsion(f, pi/4))\")\nprintln(\"Torsión en t=π/2: $(torsion(f, pi/2))\")\nprintln(\"Torsión en t=3π/4: $(torsion(f, 3pi/4))\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTorsión en t=0: 0\nTorsión en t=π/4: -1.2000000000000002\nTorsión en t=π/2: -4.3222828205200695e-17\nTorsión en t=3π/4: 1.2000000000000002\n```\n:::\n:::\n\n\n:::\n:::\n\n\n## Ejercicios propuestos\n<!-- \n\n\n\n:::{#exr-derivabilidad}\nDada la función\n\n$$\nf(x)=\n\\begin{cases}\n\\operatorname{sen}(x)^2 & \\mbox{si $x\\leq 0$},  \\\\\nax^2+b &  \\mbox{si $0<x\\leq c$},  \\\\\n\\ln(x) &  \\mbox{si $c<x$},\n\\end{cases}\n$$\n\n¿Para qué valores de $a$, $b$ y $c$ la función es derivable en todo $\\mathbb{R}$?\n\n::: {.cell execution_count=24}\n\n::: {.cell-output .cell-output-display execution_count=25}\n```{=tex}\n${\\quad\\Box}$ $$a=\\sqrt{e}, b=0, c=\\frac{1}{e}.$$\n${\\quad\\Box}$ $$a=1, b=0, c=e.$$\n${\\quad\\Box}$ Para ningún valor.\n\n${\\quad\\Box}$ $$a=\\frac{1}{2e}, b=0, c=e^{1/2}.$$\n${\\quad\\Box}$ $$a=1, b=1, c=1.$$\n```\n:::\n:::\n\n\n:::\n\n\n:::{#exr-pendientes-tangentes}\nDadas las funciones $f(x)=\\ln\\left(\\sqrt{\\dfrac{x^2}{2}}\\right)$ y $g(x)=x^3+1$, ¿en qué puntos la recta normal a $f$ y\nla recta tangente a $g$ con paralelas?\n\n::: {.cell execution_count=25}\n\n::: {.cell-output .cell-output-display execution_count=26}\n```{=tex}\n\\vspace{18pt}\n```\n:::\n:::\n\n\n:::\n\n\n\n -->\n\n",
    "supporting": [
      "08-funciones-vectoriales_files/figure-pdf"
    ],
    "filters": []
  }
}