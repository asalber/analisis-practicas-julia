---
title: Funciones vectoriales
lang: es
#jupyter: julia-1.9
---

## Ejercicios Resueltos

Para la realización de esta práctica se requieren los siguientes paquetes:

```{julia}
using SymPy  # Para el cálculo simbólico.
using Plots  # Para el dibujo de gráficas.
using Makie, GLMakie # Para el dibújo de gráficas en 3d.
#plotlyjs() # Para obtener gráficos interactivos.
using LaTeXStrings  # Para usar código LaTeX en los gráficos.
using LinearAlgebra # Para el módulo, producto escalar y vectorial de vectores.
using CalculusWithJulia # Utilidades para dibujar vectores.
```

:::{#exr-vectores}
Representar gráficamente los vectores $\mathbf{u}=(3,1)$, $\mathbf{v}=(1,2)$ y $\mathbf{u}-\mathbf{v}$ en el plano real $\mathbb{R}^2$.

:::{.callout-note collapse="true"}
## Ayuda
Usar la función [`arrow`](https://docs.juliahub.com/CalculusWithJulia/AZHbv/0.1.2/#CalculusWithJulia.arrow-Tuple) del paquete `CalculusWithJulia` para dibujar flechas que representan vectores.
:::

:::{.callout-tip collapse="true"}
## Solución

```{julia}
using CalculusWithJulia
using LaTeXStrings
O = [0, 0] # Origin
u = [3, 1]
v = [1, 2]
Plots.plot()
arrow!(O, u)
arrow!(O, v)
arrow!(v, u-v)
annotate!(1.5, 0.4, L"$\mathbf{u}$")
annotate!(0.4, 1, L"$\mathbf{v}$")
annotate!(2.1, 1.6, L"$\mathbf{u}-\mathbf{v}$")
```
:::
:::

:::{#exr-producto-escalar-vectorial}
Sean $\mathbf{u}=(1,2,-1)$ y $\mathbf{v}=(3,0,2)$ dos vectores del espacio real $\mathbb{R}^3$.

a.  Calcular el módulo (norma) de ambos vectores y construir vectores unitarios con su misma dirección.

    :::{.callout-note collapse="true"}
    ## Ayuda
    Usar la función [`norm`](https://aprendeconalf.es/manual-julia/tipos-datos-compuestos.html#%C3%A1lgebra-lineal-con-vectores) del paquete `LinearAlgebra` para calular el módulo de un vector.
    :::

    :::{.callout-tip collapse="true"}
    ## Solución

    ```{julia}
    using LinearAlgebra
    u = [-1, 2, -1]
    v = [-2, 0, 1]
    println("Módulo de u: $(norm(u))")
    println("Módulo de v: $(norm(v))")
    println("Vector unitario con la dirección de u $(u/norm(u))")
    println("Vector unitario con la dirección de v $(v/norm(v))")
    ```
    :::

a.  Calcular su producto escalar.

    :::{.callout-note collapse="true"}
    ## Ayuda
    Usar la función [`dot`](https://aprendeconalf.es/manual-julia/tipos-datos-compuestos.html#%C3%A1lgebra-lineal-con-vectores) del paquete `LinearAlgebra` para calcular el producto escalar de dos vectores.
    :::

    :::{.callout-tip collapse="true"}
    ## Solución

    ```{julia}
    println("Producto escalar de u y v $(dot(u, v))")
    # También se puede usar el clásico punto ⋅
    println("Producto escalar de u y v $(u ⋅ v)")
    ```
    :::

a.  Calcular su producto vectorial.

    :::{.callout-note collapse="true"}
    ## Ayuda
    Usar la función [`cross`](https://aprendeconalf.es/manual-julia/tipos-datos-compuestos.html#%C3%A1lgebra-lineal-con-vectores) del paquete `LinearAlgebra` para calcular el producto vectorial de dos vectores.
    :::

    :::{.callout-tip collapse="true"}
    ## Solución

    ```{julia}
    println("Producto vectorial de u y v $(cross(u, v))")
    # También se puede usar la clásica cruz × 
    println("Producto vectorial de u y v $(u × v)")
    ```
    :::

a.  Dibujar $\mathbf{u}$, $\mathbf{v}$ y $\mathbf{u}\times\mathbf{v}$ en el espacio real.

    :::{.callout-tip collapse="true"}
    ## Solución 1
    Usando el paquete `Plots`.

    ```{julia}
    using CalculusWithJulia
    Plots.plot(xlabel = "X", ylabel = "Y", zlabel = "Z", legend = false)
    O = [0, 0 ,0]
    arrow!(O, u)
    arrow!(O, v)
    arrow!(O, u × v)
    ```
    :::

    :::{.callout-tip collapse="true"}
    ## Solución 2
    Usando el paquete `Makie`.

    ```{julia}
    using GLMakie
    fig = Figure()
    ax = Axis3(fig[1,1], azimuth = -pi/4, aspect = (1,1,1))
    O = [0, 0 ,0]
    arrows!(ax, [Point3(O)], [Vec3(u), Vec3(v), Vec3(u × v)], 
        linecolor = [:blue,:red, :green], arrowcolor = [:blue,:red, :green],
        linewidth = 0.02, arrowsize = Vec3(0.1, 0.1, 0.1),
        align = :origin)
    fig
    ```
    :::
:::

:::{#exr-grafica-trayectorias}
Dibujar las trayectorias de las siguientes funciones vectoriales.

a.  $f(t)=(\operatorname{sen}(t), \cos(t))$.

    :::{.callout-note collapse="true"}
    ## Ayuda
    Usar la función [`plot`](https://aprendeconalf.es/manual-julia/graficos.html#gr%C3%A1fica-de-una-funci%C3%B3n-de-una-variable) del paquete `Plots`  o la función `lines` del paquete `Makie` para dibujar la trayectoria, pasándole cada una de las funciones componentes separadas por comas.
    :::

    :::{.callout-tip collapse="true"}
    ## Solución 1

    Usando el paquete `Plots`.

    ```{julia}
    using Plots
    using CalculusWithJulia
    f(t) = [sin(t), cos(t)] 
    ts = range(0, 2pi, length = 200)
    xs, ys = unzip(f.(ts))
    Plots.plot(xs, ys, aspect_ratio = :equal)
    ```
    :::

    :::{.callout-tip collapse="true"}
    ## Solución 2

    Usando el paquete `Makie`.

    ```{julia}
    using GLMakie
    f(t) = [sin(t), cos(t)] 
    ts = range(0, 2pi, length = 200)
    points = Point2.(f.(ts))
    fig = Figure()
    ax = Axis(fig[1,1], aspect = 1)
    lines!(ax, points, linewidth = 2, color = :blue)
    fig
    ```
    :::

a.  $\mathbf{g}(t) = (\cos(t), \operatorname{sen}(t), t/4)$.

    :::{.callout-tip collapse="true"}
    ## Solución 1

    Usando el paquete `Plots`.

    ```{julia}
    g(t) = [cos(t), sin(t), t/4] 
    ts = range(0, 2pi, length = 200)
    xs, ys, zs = unzip(g.(ts))
    Plots.plot(xs, ys, zs, aspect_ratio = :equal, xlabel = "X", ylabel = "Y", zlabel = "Z", label = "")
    ```
    :::

    :::{.callout-tip collapse="true"}
    ## Solución 2

    Usando el paquete `Makie`.

    ```{julia}
    using GLMakie
    g(t) = [cos(t), sin(t), t/4] 
    ts = range(0, 2pi, length = 200)
    points = Point3.(g.(ts))
    fig = Figure()
    ax = Axis3(fig[1,1])
    lines!(ax, points, linewidth = 2, color = :blue)
    fig
    ```
    :::
:::

:::{#exr-nudos-toricos}
Un [nudo tórico](https://en.wikipedia.org/wiki/Torus_knot) es un nudo que se forma mediante una trayectoria que gira sobre la superficie de un toro en $\mathbb{R}^3$. La función vectorial que define este tipo de nudos sobre un toro de ecuación $(r-2)^2+z^2 = 1$ es $\mathbf{f}(t) = ((2+\cos(qt))\cos(pt), (2+\cos(qt))\operatorname{sen}(pt), -\operatorname{sen}(qt))$, donde $p$ y $q$ son dos enteros primos entre si y $t\in [0,2\pi]$.

a.  Dibujar el nudo tórico  con $p=2$ y $q=3$.

    :::{.callout-tip collapse="true"}
    ## Solución

    Usando el paquete `Makie`.

    ```{julia}
    using GLMakie
    # Definimos las ecuaciones paramétricas del toro.
    U = LinRange(-pi, pi, 100)
    V = LinRange(-pi, pi, 20)
    x1 = [2cos(u) + cos(u) * cos(v) for u in U, v in V]
    y1 = [2sin(u) + sin(u) * cos(v) for u in U, v in V]
    z1 = [sin(v) for u in U, v in V]
    # Inicializamos la figura y los ejes.
    fig = Figure()
    ax = Axis3(fig[1,1], aspect = (3, 3, 1))
    # Dibujamos el toro.
    Makie.surface!(ax, x1, y1, z1; colormap = :viridis, shading = false, transparency = true, alpha = 0.5)
    # Definimos la función vectorial de nudo tórico.
    f(t) = [(2+cos(3t))cos(2t), (2+cos(3t))sin(2t), -sin(3t)] 
    # Generamos los puntos de la trayectoria del nudo tórico.
    ts = range(0, 2pi, length = 200)
    points = Point3.(f.(ts))
    # Dibujamos el nudo tórico.
    lines!(ax, points, linewidth = 3, color = :red)
    fig
    ```
    :::

a.  Definir una función para crear nudos tóricos con parámetros `p` y `q` para los enteros que definen el toro y un parámetro opcional booleano `toro`, para dibujar el toro o no.

    :::{.callout-tip collapse="true"}
    ## Solución

    ```{julia}
    using GLMakie
    function nudo_torico(ax::Axis3, p::Int64, q::Int64, toro::Bool = true)
        if toro 
            alpha = 0.5
        else
            alpha = 0
        end
        # Definimos las ecuaciones paramétricas del toro.
        U = LinRange(-pi, pi, 100)
        V = LinRange(-pi, pi, 20)
        x1 = [2cos(u) + cos(u) * cos(v) for u in U, v in V]
        y1 = [2sin(u) + sin(u) * cos(v) for u in U, v in V]
        z1 = [sin(v) for u in U, v in V]
        # Inicializamos la figura y los ejes.
        #fig = Figure()
        #ax = Axis3(fig[1,1], show_axis = true)
        # Dibujamos el toro.
        Makie.surface!(ax, x1, y1, z1; colormap = :viridis, shading = false, transparency = true, alpha = alpha)
        # Definimos la función vectorial de nudo tórico.
        f(t) = [(2+cos(q*t))cos(p*t), (2+cos(q*t))sin(p*t), -sin(q*t)] 
        # Generamos los puntos de la trayectoria del nudo tórico.
        ts = range(0, 2pi, length = 200)
        points = Point3.(f.(ts))
        # Dibujamos el nudo tórico.
        lines!(ax, points, linewidth = 3, color = :red)
    end

    fig = Figure()
    ax = Axis3(fig[1,1], aspect = (3, 3, 1))
    nudo_torico(ax, 5, 9, true)
    fig
    ```
    :::
:::

:::{#exr-tangente-normal}
a.  Calcular las ecuaciones de la recta tangente y el plano normal a la trayectoria $\mathbf{f}(t) = (\operatorname{sen}(2t), \cos(t))$ en el punto correspondiente a $t=\pi/2$ y dibujarlas.

    :::{.callout-note collapse="true"}
    ## Ayuda
    La ecuación de la recta tangente a la trayectoria de la función vectorial $\mathbf{f}(t)$ en el instante $t=a$ es $\mathbf{f}(a)+\mathbf{f}'(a)t$.
    :::

    :::{.callout-tip collapse="true"}
    ## Solución

    ```{julia}
    using SymPy, Plots
    @syms t::real
    # Definimos la función vectorial
    f(t) = [sin(2t), cos(t)]
    # Instante 
    a = pi/2
    # Dibujamos la trayectoria
    Plots.plot(f(t)..., 0, 2pi, aspect_ratio = :equal, label = "f(t)=(sen(t), cos(t))")
    # Dibujamos el punto de tangencia
    Plots.scatter!([f(a)[1]],[f(a)[2]], label = "")
    # Calculamos la derivada en el punto.
    df = subs.(diff.(f(t)), t=>a)
    # Calculamos la ecuación de la recta tangente.
    tl(t) = f(a) + df * t
    # Dibujamos la recta tangente.
    Plots.plot!(tl(t)..., -1, 1, label = "Tangente")
    # Calculamos la ecuación de la recta normal
    nl(t) = f(a) - [df[2],-df[1]] * t
    Plots.plot!(nl(t)..., -0.6, 0.6, label = "Normal")
    ```
    :::

a.  Calcular las ecuaciones de las recta tangente y el plano normal a la trayectoria $\mathbf{g}(t) = (\cos(t), \operatorname{sen}(t), \sqrt{t})$ en punto correspondiente a $t=\pi$ y dibujarlas.

    :::{.callout-tip collapse="true"}
    ## Solución

    ```{julia}
    using SymPy, LinearAlgebra, GLMakie
    @syms x, y, z, t::real
    # Definimos la función vectorial
    g(t) = [cos(t), sin(t), sqrt(t)]
    # Instante 
    a = pi/2
    # Dibujamos la trayectoria
    ts = range(0, 2pi, 200)
    points = Point3.(g.(ts))
    fig = Figure()
    ax = Axis3(fig[1,1], title = "Recta tangente y plano normal a una trayectoria", aspect = :equal)
    lines!(ax, points)
    # Dibujamos el punto de tangencia.
    Makie.scatter!([Point3(g(a))])
    # Calculamos la derivada en el punto.
    dg = subs.(diff.(g(t)), t=>a)
    # Calculamos la ecuación de la recta tangente.
    tl(t) = g(a) + dg * t
    # Dibujamos la recta tangente.
    pointstl = Point3.(tl.(range(-pi, pi, 2)))
    lines!(ax, pointstl)
    # Calculamos la ecuación del plano normal
    np(x,y) = solve(dot(([x, y, z] - g(a)),dg), z)[1]
    xs = range(-1, 1, 2)
    ys = range(0, 2, 2)
    zs = [np(x,y) for x in xs, y in ys]
    Makie.surface!(ax, xs, ys, zs, colormap = ["red"], alpha = 0.5, transparency = true)
    fig
    ```
    :::
:::

:::{#exr-plano-osculador}
Dada una función vectorial $\mathbf{f}(t)$ en $\mathbb{R}^3$, el _plano osculador_ de la trayectoria de $\mathbf{f}(t)$ en $t=a$ es el plano definido por los vectores tangente $\mathbf{T}(a)$ y normal $\mathbf{N}(a)$. 

Calcular y dibujar el plano osculador de la función vectorial del nudo tórico del apartado a del ejercicio @exr-nudos-toricos en el punto correspondiente a $t=\pi/2$.

:::{.callout-tip collapse="true"}
## Solución

Usando el paquete `Makie`.

```{julia}
using SymPy, LinearAlgebra, GLMakie
@syms x, y, z, t::real
# Definimos las ecuaciones paramétricas del toro.
U = LinRange(-pi, pi, 100)
V = LinRange(-pi, pi, 20)
x1 = [2cos(u) + cos(u) * cos(v) for u in U, v in V]
y1 = [2sin(u) + sin(u) * cos(v) for u in U, v in V]
z1 = [sin(v) for u in U, v in V]
# Inicializamos la figura y los ejes.
fig = Figure()
ax = Axis3(fig[1,1], aspect = (3, 3, 1))
# Dibujamos el toro.
Makie.surface!(ax, x1, y1, z1; colormap = :viridis, shading = false, transparency = true, alpha = 0.5)
# Definimos la función vectorial de nudo tórico.
f(t) = [(2+cos(3t))cos(2t), (2+cos(3t))sin(2t), -sin(3t)] 
# Generamos los puntos de la trayectoria del nudo tórico.
ts = range(0, 2pi, length = 200)
points = Point3.(f.(ts))
# Dibujamos el nudo tórico.
lines!(ax, points, linewidth = 3, color = :red)
# Punto
a = pi/2
# Dibujamos el punto
Makie.scatter!(ax, [Point3(f(a))])
# Vector tangente unitario
Tan(t) = diff.(f(t)) / norm(diff.(f(t)))
Ta = subs.(Tan(t), t=>a)
# Vector normal unitario
Norm(t) = diff.(Tan(t)) / norm(diff.(Tan(t)))
Na = subs.(Norm(t), t=>a)
# Calculamos la ecuación del plano osculador
po(x,y) = solve(dot(([x, y, z] - f(a)), cross(Ta, Na)), z)[1]
xs = range(-3, -1, 2)
ys = range(-1, 1, 2)
zs = [po(x,y) for x in xs, y in ys]
Makie.surface!(ax, xs, ys, zs, colormap = ["magenta"], alpha = 0.8, transparency = true)
fig
```
:::
:::

:::{#exr-longitud-trayectoria}
Para construir un cuaderno de 30 cm de altura se utiliza una espiral de alambre con radio 1 cm y una distancia entre cada dos vueltas consecutivas $\pi/4$ cm. Dibujar la espiral y calcular la cantidad de alambre necesaria para cada cuaderno.

:::{.callout-note collapse="true"}
## Ayuda
La [longitud de la trayectoria de una función vectorial](https://aprendeconalf.es/analisis-manual/12-funciones-vectoriales.html#longitud-de-la-trayectoria-de-una-funci%C3%B3n-vectorial) $\mathbf{fe}(t)$ en el intervalo $t\in [a,b]$ se calcula mediante la integral

$$
\int_a^b |\mathbf{f}'(t)|\, dt
$$
:::

:::{.callout-tip collapse="true"}
## Solución
Dibujamos primero la espiral.

```{julia}
using SymPy, GLMakie
@syms t::real
# Definimos la función vectorial
f(t) = [cos(t), sin(t), t/8]
# Calculamos el número de revoluciones
h = solve(f(t)[3]-30)[1]
# Dibujamos la trayectoria
ts = range(0, 240, 2000)
points = Point3.(f.(ts))
fig = Figure()
ax = Axis3(fig[1,1], title = "Espiral de un cuaderno", aspect = (1, 1, 30))
lines!(ax, points)
fig
```

A continuación calculamos la longitud de la espiral.

```{julia}
using LinearAlgebra
# Calculamos la derivada en el punto.
N(integrate(norm(diff.(f(t))), 0, h))
```
:::
:::



## Ejercicios propuestos
<!-- 
```{julia}
#| echo: false
#| results: "hidden"
using QuizQuestions
nothing
```

:::{#exr-derivabilidad}
Dada la función

$$
f(x)=
\begin{cases}
\operatorname{sen}(x)^2 & \mbox{si $x\leq 0$},  \\
ax^2+b &  \mbox{si $0<x\leq c$},  \\
\ln(x) &  \mbox{si $c<x$},
\end{cases}
$$

¿Para qué valores de $a$, $b$ y $c$ la función es derivable en todo $\mathbb{R}$?

```{julia}
#| echo: false
using SymPy
@syms x::real a::real b::real c::real
f1(x) = sin(x)^2
f2(x) = a*x^2+b
f3(x) = log(x)
nonlinsolve([limit(f1, 0, dir="-") - limit(f2, 0, dir="+"),limit(f2(x), x, c, dir="-") - limit(f3, c, dir="+")], (a,b,c))
solve(limit(f1, 0, dir="-") - limit(f2, 0, dir="+"))
solve(limit(f2(x), x, c, dir="-") - limit(f3, c, dir="+"))[1]
choices = (L"a=\sqrt{e}, b=0, c=\frac{1}{e}.", L"a=\frac{1}{2e}, b=0, c=e^{1/2}.", L"a=1, b=1, c=1.", L"a=1, b=0, c=e.", "Para ningún valor.")
answer = 2
radioq(choices, answer)
```
:::


:::{#exr-pendientes-tangentes}
Dadas las funciones $f(x)=\ln\left(\sqrt{\dfrac{x^2}{2}}\right)$ y $g(x)=x^3+1$, ¿en qué puntos la recta normal a $f$ y
la recta tangente a $g$ con paralelas?

```{julia}
#| echo: false
using SymPy
@syms x::real
f(x) = ln(sqrt(x^2/2))
g(x) = x^3+x^2-1
sol = solve(Eq(-1/diff(f), diff(g)))[1]
numericq(sol, 1e-15)
```
:::



 -->
