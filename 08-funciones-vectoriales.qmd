---
title: Funciones vectoriales
lang: es
#jupyter: julia-1.9
---

## Ejercicios Resueltos

Para la realización de esta práctica se requieren los siguientes paquetes:

```{julia}
using SymPy  # Para el cálculo simbólico.
using Plots  # Para el dibujo de gráficas.
using Makie, GLMakie # Para el dibújo de gráficas en 3d.
#plotlyjs() # Para obtener gráficos interactivos.
using LaTeXStrings  # Para usar código LaTeX en los gráficos.
using LinearAlgebra # Para el módulo, producto escalar y vectorial de vectores.
using Roots # Para calcular soluciones de ecuaciones numéricamente.
using CalculusWithJulia # Utilidades para dibujar vectores.
```

:::{#exr-vectores}
Representar gráficamente los vectores $\mathbf{u}=(3,1)$, $\mathbf{v}=(1,2)$ y $\mathbf{u}-\mathbf{v}$ en el plano real $\mathbb{R}^2$.

:::{.callout-note collapse="true"}
## Ayuda
Usar la función [`arrow`](https://docs.juliahub.com/CalculusWithJulia/AZHbv/0.1.2/#CalculusWithJulia.arrow-Tuple) del paquete `CalculusWithJulia` para dibujar flechas que representan vectores.
:::

:::{.callout-tip collapse="true"}
## Solución

```{julia}
using CalculusWithJulia
using LaTeXStrings
O = [0, 0] # Origin
u = [3, 1]
v = [1, 2]
Plots.plot()
arrow!(O, u)
arrow!(O, v)
arrow!(v, u-v)
annotate!(1.5, 0.4, L"$\mathbf{u}$")
annotate!(0.4, 1, L"$\mathbf{v}$")
annotate!(2.1, 1.6, L"$\mathbf{u}-\mathbf{v}$")
```
:::
:::

:::{#exr-producto-escalar-vectorial}
Sean $\mathbf{u}=(1,2,-1)$ y $\mathbf{v}=(3,0,2)$ dos vectores del espacio real $\mathbb{R}^3$.

a.  Calcular el módulo (norma) de ambos vectores y construir vectores unitarios con su misma dirección.

    :::{.callout-note collapse="true"}
    ## Ayuda
    Usar la función [`norm`](https://aprendeconalf.es/manual-julia/tipos-datos-compuestos.html#%C3%A1lgebra-lineal-con-vectores) del paquete `LinearAlgebra` para calular el módulo de un vector.
    :::

    :::{.callout-tip collapse="true"}
    ## Solución

    ```{julia}
    using LinearAlgebra
    u = [-1, 2, -1]
    v = [-2, 0, 1]
    println("Módulo de u: $(norm(u))")
    println("Módulo de v: $(norm(v))")
    println("Vector unitario con la dirección de u $(u/norm(u))")
    println("Vector unitario con la dirección de v $(v/norm(v))")
    ```
    :::

a.  Calcular su producto escalar.

    :::{.callout-note collapse="true"}
    ## Ayuda
    Usar la función [`dot`](https://aprendeconalf.es/manual-julia/tipos-datos-compuestos.html#%C3%A1lgebra-lineal-con-vectores) del paquete `LinearAlgebra` para calcular el producto escalar de dos vectores.
    :::

    :::{.callout-tip collapse="true"}
    ## Solución

    ```{julia}
    println("Producto escalar de u y v $(dot(u, v))")
    # También se puede usar el clásico punto ⋅
    println("Producto escalar de u y v $(u ⋅ v)")
    ```
    :::

a.  Calcular su producto vectorial.

    :::{.callout-note collapse="true"}
    ## Ayuda
    Usar la función [`cross`](https://aprendeconalf.es/manual-julia/tipos-datos-compuestos.html#%C3%A1lgebra-lineal-con-vectores) del paquete `LinearAlgebra` para calcular el producto vectorial de dos vectores.
    :::

    :::{.callout-tip collapse="true"}
    ## Solución

    ```{julia}
    println("Producto vectorial de u y v $(cross(u, v))")
    # También se puede usar la clásica cruz × 
    println("Producto vectorial de u y v $(u × v)")
    ```
    :::

a.  Dibujar $\mathbf{u}$, $\mathbf{v}$ y $\mathbf{u}\times\mathbf{v}$ en el espacio real.

    :::{.callout-tip collapse="true"}
    ## Solución 1
    Usando el paquete `Plots`.

    ```{julia}
    using CalculusWithJulia
    Plots.plot(xlabel = "X", ylabel = "Y", zlabel = "Z", legend = false)
    O = [0, 0 ,0]
    arrow!(O, u)
    arrow!(O, v)
    arrow!(O, u × v)
    ```
    :::

    :::{.callout-tip collapse="true"}
    ## Solución 2
    Usando el paquete `Makie`.

    ```{julia}
    using GLMakie
    fig = Figure()
    ax = Axis3(fig[1,1], azimuth = -pi/4, aspect = (1,1,1))
    O = [0, 0 ,0]
    arrows!(ax, [Point3(O)], [Vec3(u), Vec3(v), Vec3(u × v)], 
        linecolor = [:blue,:red, :green], arrowcolor = [:blue,:red, :green],
        linewidth = 0.02, arrowsize = Vec3(0.1, 0.1, 0.1))
    fig
    ```
    :::
:::

:::{#exr-grafica-trayectorias}
Dibujar las trayectorias de las siguientes funciones vectoriales.

a.  $f(t)=(\operatorname{sen}(t), \cos(t))$.

    :::{.callout-note collapse="true"}
    ## Ayuda
    Usar la función [`plot`](https://aprendeconalf.es/manual-julia/graficos.html#gr%C3%A1fica-de-una-funci%C3%B3n-de-una-variable) del paquete `Plots`  o la función `lines` del paquete `Makie` para dibujar la trayectoria, pasándole cada una de las funciones componentes separadas por comas.
    :::

    :::{.callout-tip collapse="true"}
    ## Solución 1

    Usando el paquete `Plots`.

    ```{julia}
    using Plots
    using CalculusWithJulia
    f(t) = [sin(t), cos(t)] 
    ts = range(0, 2pi, length = 200)
    xs, ys = unzip(f.(ts))
    Plots.plot(xs, ys, aspect_ratio = :equal)
    ```
    :::

    :::{.callout-tip collapse="true"}
    ## Solución 2

    Usando el paquete `Makie`.

    ```{julia}
    using GLMakie
    f(t) = [sin(t), cos(t)] 
    ts = range(0, 2pi, length = 200)
    points = Point2.(f.(ts))
    fig = Figure()
    ax = Axis(fig[1,1], aspect = 1)
    lines!(ax, points, linewidth = 2, color = :blue)
    fig
    ```
    :::

a.  $\mathbf{g}(t) = (\cos(t), \operatorname{sen}(t), t/4)$.

    :::{.callout-tip collapse="true"}
    ## Solución 1

    Usando el paquete `Plots`.

    ```{julia}
    g(t) = [cos(t), sin(t), t/4] 
    ts = range(0, 2pi, length = 200)
    xs, ys, zs = unzip(g.(ts))
    Plots.plot(xs, ys, zs, aspect_ratio = :equal, xlabel = "X", ylabel = "Y", zlabel = "Z", label = "")
    ```
    :::

    :::{.callout-tip collapse="true"}
    ## Solución 2

    Usando el paquete `Makie`.

    ```{julia}
    using GLMakie
    g(t) = [cos(t), sin(t), t/4] 
    ts = range(0, 2pi, length = 200)
    points = Point3.(g.(ts))
    fig = Figure()
    ax = Axis3(fig[1,1])
    lines!(ax, points, linewidth = 2, color = :blue)
    fig
    ```
    :::
:::

:::{#exr-nudos-toricos}
Un [nudo tórico](https://en.wikipedia.org/wiki/Torus_knot) es un nudo que se forma mediante una trayectoria que gira sobre la superficie de un toro en $\mathbb{R}^3$. La función vectorial que define este tipo de nudos sobre un toro de ecuación $(r-2)^2+z^2 = 1$ es $\mathbf{f}(t) = ((2+\cos(qt))\cos(pt), (2+\cos(qt))\operatorname{sen}(pt), -\operatorname{sen}(qt))$, donde $p$ y $q$ son dos enteros primos entre si y $t\in [0,2\pi]$.

a.  Dibujar el nudo tórico  con $p=2$ y $q=3$.

    :::{.callout-tip collapse="true"}
    ## Solución

    Usando el paquete `Makie`.

    ```{julia}
    using GLMakie
    # Definimos las ecuaciones paramétricas del toro.
    U = LinRange(-pi, pi, 100)
    V = LinRange(-pi, pi, 20)
    x1 = [2cos(u) + cos(u) * cos(v) for u in U, v in V]
    y1 = [2sin(u) + sin(u) * cos(v) for u in U, v in V]
    z1 = [sin(v) for u in U, v in V]
    # Inicializamos la figura y los ejes.
    fig = Figure()
    ax = Axis3(fig[1,1], aspect = (3, 3, 1))
    # Dibujamos el toro.
    Makie.surface!(ax, x1, y1, z1; colormap = :viridis, shading = false, transparency = true, alpha = 0.5)
    # Definimos la función vectorial de nudo tórico.
    f(t) = [(2+cos(3t))cos(2t), (2+cos(3t))sin(2t), -sin(3t)] 
    # Generamos los puntos de la trayectoria del nudo tórico.
    ts = range(0, 2pi, length = 200)
    points = Point3.(f.(ts))
    # Dibujamos el nudo tórico.
    lines!(ax, points, linewidth = 3, color = :red)
    fig
    ```
    :::

a.  Definir una función para crear nudos tóricos con parámetros `p` y `q` para los enteros que definen el toro y un parámetro opcional booleano `toro`, para dibujar el toro o no.

    :::{.callout-tip collapse="true"}
    ## Solución

    ```{julia}
    using GLMakie
    """
        nudo_torico(ax, p, q, toro)

    Función dibuja un nudo tórico de parámetros p, q sobre los ejes ax. Si el parámetro toro es true dibuja también el toro sobre el que se traza el nudo.
    """
    function nudo_torico(ax::Axis3, p::Int64, q::Int64, toro::Bool = true)
        if toro 
            alpha = 0.5
        else
            alpha = 0
        end
        # Definimos las ecuaciones paramétricas del toro.
        U = LinRange(-pi, pi, 100)
        V = LinRange(-pi, pi, 20)
        x1 = [2cos(u) + cos(u) * cos(v) for u in U, v in V]
        y1 = [2sin(u) + sin(u) * cos(v) for u in U, v in V]
        z1 = [sin(v) for u in U, v in V]
        # Inicializamos la figura y los ejes.
        #fig = Figure()
        #ax = Axis3(fig[1,1], show_axis = true)
        # Dibujamos el toro.
        Makie.surface!(ax, x1, y1, z1; colormap = :viridis, shading = false, transparency = true, alpha = alpha)
        # Definimos la función vectorial de nudo tórico.
        f(t) = [(2+cos(q*t))cos(p*t), (2+cos(q*t))sin(p*t), -sin(q*t)] 
        # Generamos los puntos de la trayectoria del nudo tórico.
        ts = range(0, 2pi, length = 200)
        points = Point3.(f.(ts))
        # Dibujamos el nudo tórico.
        lines!(ax, points, linewidth = 3, color = :red)
    end

    fig = Figure()
    ax = Axis3(fig[1,1], aspect = (3, 3, 1))
    nudo_torico(ax, 5, 9, true)
    fig
    ```
    :::
:::

:::{#exr-tangente-normal}
a.  Calcular las ecuaciones de la recta tangente y el plano normal a la trayectoria $\mathbf{f}(t) = (\operatorname{sen}(2t), \cos(t))$ en el punto correspondiente a $t=\pi/2$ y dibujarlas.

    :::{.callout-note collapse="true"}
    ## Ayuda
    La ecuación de la recta tangente a la trayectoria de la función vectorial $\mathbf{f}(t)$ en el instante $t=a$ es $\mathbf{f}(a)+\mathbf{f}'(a)t$.
    :::

    :::{.callout-tip collapse="true"}
    ## Solución

    ```{julia}
    using SymPy, Plots
    @syms t::real
    # Definimos la función vectorial
    f(t) = [sin(2t), cos(t)]
    # Instante 
    a = pi/2
    # Dibujamos la trayectoria
    Plots.plot(f(t)..., 0, 2pi, aspect_ratio = :equal, label = "f(t)=(sen(t), cos(t))")
    # Dibujamos el punto de tangencia
    Plots.scatter!([f(a)[1]],[f(a)[2]], label = "")
    # Calculamos la derivada en el punto.
    df = subs.(diff.(f(t)), t=>a)
    # Calculamos la ecuación de la recta tangente.
    tl(t) = f(a) + df * t
    # Dibujamos la recta tangente.
    Plots.plot!(tl(t)..., -1, 1, label = "Tangente")
    # Calculamos la ecuación de la recta normal
    nl(t) = f(a) - [df[2],-df[1]] * t
    Plots.plot!(nl(t)..., -0.6, 0.6, label = "Normal")
    ```
    :::

a.  Calcular las ecuaciones de las recta tangente y el plano normal a la trayectoria $\mathbf{g}(t) = (\cos(t), \operatorname{sen}(t), \sqrt{t})$ en punto correspondiente a $t=\pi$ y dibujarlas.

    :::{.callout-tip collapse="true"}
    ## Solución

    ```{julia}
    using SymPy, LinearAlgebra, GLMakie
    @syms x, y, z, t::real
    # Definimos la función vectorial
    g(t) = [cos(t), sin(t), sqrt(t)]
    # Instante 
    a = pi/2
    # Dibujamos la trayectoria
    ts = range(0, 2pi, 200)
    points = Point3.(g.(ts))
    fig = Figure()
    ax = Axis3(fig[1,1], title = "Recta tangente y plano normal a una trayectoria", aspect = :equal)
    lines!(ax, points)
    # Dibujamos el punto de tangencia.
    Makie.scatter!([Point3(g(a))])
    # Calculamos la derivada en el punto.
    dg = subs.(diff.(g(t)), t=>a)
    # Calculamos la ecuación de la recta tangente.
    tl(t) = g(a) + dg * t
    # Dibujamos la recta tangente.
    pointstl = Point3.(tl.(range(-pi, pi, 2)))
    lines!(ax, pointstl)
    # Calculamos la ecuación del plano normal
    np(x,y) = solve(dot(([x, y, z] - g(a)),dg), z)[1]
    xs = range(-1, 1, 2)
    ys = range(0, 2, 2)
    zs = [np(x,y) for x in xs, y in ys]
    Makie.surface!(ax, xs, ys, zs, colormap = ["red"], alpha = 0.5, transparency = true)
    fig
    ```
    :::
:::

:::{#exr-plano-osculador}
Dada una función vectorial $\mathbf{f}(t)$ en $\mathbb{R}^3$, el _plano osculador_ de la trayectoria de $\mathbf{f}(t)$ en $t=a$ es el plano definido por los vectores tangente $\mathbf{T}(a)$ y normal $\mathbf{N}(a)$. 

Calcular y dibujar el plano osculador de la función vectorial del nudo tórico del apartado a del ejercicio @exr-nudos-toricos en el punto correspondiente a $t=\pi/2$.

:::{.callout-tip collapse="true"}
## Solución

Usando el paquete `Makie`.

```{julia}
using SymPy, LinearAlgebra, GLMakie
@syms x, y, z, t::real
# Definimos las ecuaciones paramétricas del toro.
U = LinRange(-pi, pi, 100)
V = LinRange(-pi, pi, 20)
x1 = [2cos(u) + cos(u) * cos(v) for u in U, v in V]
y1 = [2sin(u) + sin(u) * cos(v) for u in U, v in V]
z1 = [sin(v) for u in U, v in V]
# Inicializamos la figura y los ejes.
fig = Figure()
ax = Axis3(fig[1,1], aspect = (3, 3, 1))
# Dibujamos el toro.
Makie.surface!(ax, x1, y1, z1; colormap = :viridis, shading = false, transparency = true, alpha = 0.5)
# Definimos la función vectorial de nudo tórico.
f(t) = [(2+cos(3t))cos(2t), (2+cos(3t))sin(2t), -sin(3t)] 
# Generamos los puntos de la trayectoria del nudo tórico.
ts = range(0, 2pi, length = 200)
points = Point3.(f.(ts))
# Dibujamos el nudo tórico.
lines!(ax, points, linewidth = 3, color = :red)
# Punto
a = pi/2
# Dibujamos el punto
Makie.scatter!(ax, [Point3(f(a))])
# Vector tangente unitario
Tan(t) = diff.(f(t)) / norm(diff.(f(t)))
Ta = subs.(Tan(t), t=>a)
# Vector normal unitario
Norm(t) = diff.(Tan(t)) / norm(diff.(Tan(t)))
Na = subs.(Norm(t), t=>a)
# Calculamos la ecuación del plano osculador
po(x,y) = solve(dot(([x, y, z] - f(a)), cross(Ta, Na)), z)[1]
xs = range(-3, -1, 2)
ys = range(-1, 1, 2)
zs = [po(x,y) for x in xs, y in ys]
Makie.surface!(ax, xs, ys, zs, colormap = ["magenta"], alpha = 0.8, transparency = true)
fig
```
:::
:::

:::{#exr-longitud-trayectoria}
Para construir un cuaderno de 30 cm de altura se utiliza una espiral de alambre con radio 1 cm y una distancia entre cada dos vueltas consecutivas $\pi/4$ cm. Dibujar la espiral y calcular la cantidad de alambre necesaria para cada cuaderno.

:::{.callout-note collapse="true"}
## Ayuda
La [longitud de la trayectoria de una función vectorial](https://aprendeconalf.es/analisis-manual/12-funciones-vectoriales.html#longitud-de-la-trayectoria-de-una-funci%C3%B3n-vectorial) $\mathbf{fe}(t)$ en el intervalo $t\in [a,b]$ se calcula mediante la integral

$$
\int_a^b |\mathbf{f}'(t)|\, dt
$$
:::

:::{.callout-tip collapse="true"}
## Solución
Dibujamos primero la espiral.

```{julia}
using SymPy, GLMakie
@syms t::real
# Definimos la función vectorial
f(t) = [cos(t), sin(t), t/8]
# Calculamos el número de revoluciones
h = solve(f(t)[3]-30)[1]
# Dibujamos la trayectoria
ts = range(0, 240, 2000)
points = Point3.(f.(ts))
fig = Figure()
ax = Axis3(fig[1,1], title = "Espiral de un cuaderno", aspect = (1, 1, 30))
lines!(ax, points)
fig
```

A continuación calculamos la longitud de la espiral.

```{julia}
using LinearAlgebra
# Calculamos la derivada en el punto.
N(integrate(norm(diff.(f(t))), 0, h))
```
:::
:::

:::{#exr-curvatura}
Dibujar función de curvatura de campana de Gauss correspondiente a la función de densidad de una distribución normal estándar

$$
f(x) = \frac{1}{\sqrt{2\pi}}e^{-x^2/2}.
$$

¿En qué puntos la curvatura es nula? ¿Dónde la curvatura es máxima localmente?

:::{.callout-note collapse="true"}
## Ayuda
La [curvatura de la gráfica de una función real](https://aprendeconalf.es/analisis-ejercicios/10-funciones-vectoriales.html#exr-curvatura-funcion) $f(x)$ se calcula mediante la fórmula 

$$
\kappa(x) = \frac{|f''(x)|}{(1+f''(x)^2)^{3/2}}.
$$
:::

:::{.callout-tip collapse="true"}
## Solución

Dibujamos primero la gráfica de la función y la de la función curvatura.

```{julia}
using SymPy, GLMakie
@syms x::real
# Definimos la función 
f(x) = 1/sqrt(2pi) * exp(-x^2/2)
# Dibujamos la gráfica de la función
fig = Figure()
ax = Axis(fig[1,1], autolimitaspect = 1)
lines!(ax, -3..3, f, label = L"$f(t)= \frac{1}{\sqrt{2\pi}}e^{-x^2/2}$")
fig
# Calculamos la segunda derivada de la función
df2 = diff(f, 2)
# Calculamos la función de curvatura
k(x) = abs(df2(x)) / (1 + df2(x)^2)^(3/2)
# Definimos una serie de puntos de la función curvatura
xs = range(-3, 3, 200)
points = Point2.(xs, k.(xs))
# Dibujamos la función de curvatura
lines!(ax, points, label = "Curvatura")
# Añadimos la leyenda
axislegend()
fig
```

Ahora calculamos los puntos con curvatura máxima y mínima localmente.

```{julia}
# Calculamos los puntos que anulan la curvatura.
solve(k(x),x)
# Calculamos los puntos críticos de la curvatura.
# solve(diff(k(x)), x) No encuentra la solución, así que buscamos la solución numéricamente.
using Roots
println("Máximo local en x = $(find_zero(diff(k(x)), -2))")
println("Máximo local en x = $(find_zero(diff(k(x)), 0))")
println("Máximo local en x = $(find_zero(diff(k(x)), 2))")
```
:::
:::

:::{#exr-curvatura-torsion}
La _torsión_ de una trayectoria de una función vectorial $\mathbf{f}(t)$ en el espacio real $\mathbb{R}^3$ mide la intensidad con la que una curva se sale del plano osculador y se calcula con la fórmula

$$
\tau(t) = \frac{(\mathbf{f}'(t)\times \mathbf{f}''(t))\mathbf{f}'''(t)}{|\mathbf{f}'(t)\times \mathbf{f}''(t)|^2}
$$

Definir una función para la curvatura y y otra para la torsión de la trayectoria de la función vectorial $\mathbf{h}(t)=\cos(2t)\mathbf{i} + \operatorname{sen}(t) \mathbf{j} + \cos(t) \mathbf{k}$, y utilizarla para calcular la curvatura y la torsión en los instantes $t=0, \pi/4, \pi/2, 3\pi/2$.

:::{.callout-tip collapse="true"}
## Solución

Calculamos primero la curvatura.

```{julia}
using SymPy, LinearAlgebra
"""
    curvatura(h, a)

Calcula la curvatura de la trayectoria de una función vectorial h en el punto a.
"""
function curvatura(f, a)
    @syms t::real
    # Calculamos la primera derivada.
    df(t) = diff.(f(t))
    # Calculamos la segunda derivada.
    df2(t) = diff.(df(t))
    # Calculamos la curvatura
    k(t) = norm(cross(df(t), df2(t))) / norm(df(t))^3
    return N(subs(k(t), t=>a))
end

f(t) = [cos(2t), sin(t), cos(t)]
println("Curvatura en t=0: $(curvatura(f, 0))")
println("Curvatura en t=π/4: $(curvatura(f, pi/4))")
println("Curvatura en t=π/2: $(curvatura(f, pi/2))")
println("Curvatura en t=3π/4: $(curvatura(f, 3pi/4))")
```

Y ahora calculamos la torsión.


```{julia}
using SymPy, LinearAlgebra
"""
    torsion(h, a)

Calcula la torsion de la trayectoria de una función vectorial h en el punto a.
"""
function torsion(f, a)
    @syms t::real
    # Calculamos la primera derivada.
    df(t) = diff.(f(t))
    # Calculamos la segunda derivada.
    df2(t) = diff.(df(t))
    # Calculamos la tercera derivada.
    df3(t) = diff.(df2(t))
    # Calculamos la torsión.
    τ(t) = dot(cross(df(t), df2(t)), df3(t)) / norm(cross(df(t), df2(t)))^2
    return N(subs(τ(t), t=>a))
end

println("Torsión en t=0: $(torsion(f, 0))")
println("Torsión en t=π/4: $(torsion(f, pi/4))")
println("Torsión en t=π/2: $(torsion(f, pi/2))")
println("Torsión en t=3π/4: $(torsion(f, 3pi/4))")
```
:::
:::

:::{#exr-cinematica} 
Se lanza una pelota desde la terraza de un edificio de altura $h$ con una rapidez inicial $r$ y un ángulo sobre el horizonte $\theta$. Estudiar la trayectoria que describe la pelota suponiendo que la única fuerza que actúa sobre ella es la de la gravedad.

a.  Definir una función para calcular la función vectorial de la posición de la pelota tomando como parámetros la altura del edificio, la rapidez inicial y el ángulo de lanzamiento.

    :::{.callout-tip collapse="true"}
    ## Solución

    ```{julia}
    using SymPy
    """
        pelota(h, r, θ)

    Devuelve un vector con las componentes de la función vectorial que define la posición de una pelota lanzada desde una altura h, con una rapidez r y un ángulo de lanzamiento θ con respecto al horizonte.
    """
    function pelota(h, r, θ)
        @syms t::positive
        g = 9.81
        v₀ = [r*cos(θ), r*sin(θ)]
        a(t) = [Sym(0), -Sym(g)]
        v(t) = integrate.(a(t), t) + v₀
        return integrate.(v(t), t) + [0, h]
    end
    ```
    :::

a.  Construir una función para dibujar la gráfica de la trayectoria de la pelota tomando como parámetros la altura del edificio, la rapidez inicial y el ángulo de lanzamiento.

    :::{.callout-tip collapse="true"}
    ## Solución

    ```{julia}
    using GLMakie
    """
        trayectoria_pelota(ax, h, r, θ)

    Dibuja sobre los ejes ax la gráfica de la trayectoria de una pelota lanzada desde una altura h, con una rapidez r y un ángulo de lanzamiento θ con respecto al horizonte.
    """
    function trayectoria_pelota!(ax, h, r, θ)
        @syms t::positive
        f = lambdify(pelota(h, r, θ))
        t₀ = solve(f(t)[2], t)[1]
        ts = range(0, t₀, 200)
        points = Point2.(f.(ts))
        lines!(ax, points, label = "h =$(h), r = $(r), θ = $(θ)")
        return ax
    end

    fig = Figure()
    ax = Axis(fig[1,1], title = "Trayectoria de la pelota", aspect = DataAspect())
    trayectoria_pelota!(ax, 100, 20, PI/4)
    trayectoria_pelota!(ax, 100, 20, PI/6)
    trayectoria_pelota!(ax, 100, 20, PI/8)
    trayectoria_pelota!(ax, 100, 20, PI/10)
    # Añadimos la leyenda
    axislegend(position = :lb)
    fig
    ```
    :::

a.  Si se lanza la pelota a nivel del suelo, con una rapidez de 20 m/s ¿para qué ángulo se alcanzará una mayor distancia? ¿Y si se lanza desde 100 m de altura?

    :::{.callout-tip collapse="true"}
    ## Solución

    Calculamos primero el ángulo para una altura 0.
    ```{julia}
    @syms θ, t:: positive
    f(t) = pelota(0, 20, θ)
    t₀ = solve(f(t)[2], t)[1]
    solve(diff(subs(f(t)[1], t=>t₀), θ))
    ```

    Y ahora para una altura de 100 m.

    ```{julia}
    using Roots
    @syms θ, t:: positive
    f(t) = pelota(100, 20, θ)
    t₀ = solve(f(t)[2], t)[2]
    find_zero(diff(subs(f(t)[1], t=>t₀), θ), 0.5)
    ```
    :::

a.  Determinar las componentes tangencial y normal del vector aceleración. 

:::

## Ejercicios propuestos
<!-- 
```{julia}
#| echo: false
#| results: "hidden"
using QuizQuestions
nothing
```

:::{#exr-derivabilidad}
Dada la función

$$
f(x)=
\begin{cases}
\operatorname{sen}(x)^2 & \mbox{si $x\leq 0$},  \\
ax^2+b &  \mbox{si $0<x\leq c$},  \\
\ln(x) &  \mbox{si $c<x$},
\end{cases}
$$

¿Para qué valores de $a$, $b$ y $c$ la función es derivable en todo $\mathbb{R}$?

```{julia}
#| echo: false
using SymPy
@syms x::real a::real b::real c::real
f1(x) = sin(x)^2
f2(x) = a*x^2+b
f3(x) = log(x)
nonlinsolve([limit(f1, 0, dir="-") - limit(f2, 0, dir="+"),limit(f2(x), x, c, dir="-") - limit(f3, c, dir="+")], (a,b,c))
solve(limit(f1, 0, dir="-") - limit(f2, 0, dir="+"))
solve(limit(f2(x), x, c, dir="-") - limit(f3, c, dir="+"))[1]
choices = (L"a=\sqrt{e}, b=0, c=\frac{1}{e}.", L"a=\frac{1}{2e}, b=0, c=e^{1/2}.", L"a=1, b=1, c=1.", L"a=1, b=0, c=e.", "Para ningún valor.")
answer = 2
radioq(choices, answer)
```
:::


:::{#exr-pendientes-tangentes}
Dadas las funciones $f(x)=\ln\left(\sqrt{\dfrac{x^2}{2}}\right)$ y $g(x)=x^3+1$, ¿en qué puntos la recta normal a $f$ y
la recta tangente a $g$ con paralelas?

```{julia}
#| echo: false
using SymPy
@syms x::real
f(x) = ln(sqrt(x^2/2))
g(x) = x^3+x^2-1
sol = solve(Eq(-1/diff(f), diff(g)))[1]
numericq(sol, 1e-15)
```
:::



 -->
